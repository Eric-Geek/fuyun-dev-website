"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Orb.tsx":
/*!****************************!*\
  !*** ./components/Orb.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Orb)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Texture.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/math/Vec3.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Mesh.js\");\n/* harmony import */ var _Orb_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Orb.css */ \"(app-pages-browser)/./components/Orb.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction Orb(param) {\n    let { hue = 0, hoverIntensity = 0.2, rotateOnHover = true, forceHoverState = false, avatarUrl } = param;\n    _s();\n    const ctnDom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const vert = \"\\n    precision highp float;\\n    attribute vec2 position;\\n    attribute vec2 uv;\\n    varying vec2 vUv;\\n    void main() {\\n      vUv = uv;\\n      gl_Position = vec4(position, 0.0, 1.0);\\n    }\\n  \";\n    const frag = \"\\n    precision highp float;\\n\\n    uniform float iTime;\\n    uniform vec3 iResolution;\\n    uniform float hue;\\n    uniform float hover;\\n    uniform float rot;\\n    uniform float hoverIntensity;\\n    uniform sampler2D tMap;\\n    uniform float hasTexture;\\n    varying vec2 vUv;\\n\\n    vec3 rgb2yiq(vec3 c) {\\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\\n      return vec3(y, i, q);\\n    }\\n    \\n    vec3 yiq2rgb(vec3 c) {\\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\\n      return vec3(r, g, b);\\n    }\\n    \\n    vec3 adjustHue(vec3 color, float hueDeg) {\\n      float hueRad = hueDeg * 3.14159265 / 180.0;\\n      vec3 yiq = rgb2yiq(color);\\n      float cosA = cos(hueRad);\\n      float sinA = sin(hueRad);\\n      float i = yiq.y * cosA - yiq.z * sinA;\\n      float q = yiq.y * sinA + yiq.z * cosA;\\n      yiq.y = i;\\n      yiq.z = q;\\n      return yiq2rgb(yiq);\\n    }\\n\\n    vec3 hash33(vec3 p3) {\\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\\n      p3 += dot(p3, p3.yxz + 19.19);\\n      return -1.0 + 2.0 * fract(vec3(\\n        p3.x + p3.y,\\n        p3.x + p3.z,\\n        p3.y + p3.z\\n      ) * p3.zyx);\\n    }\\n\\n    float snoise3(vec3 p) {\\n      const float K1 = 0.333333333;\\n      const float K2 = 0.166666667;\\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n      vec3 i1 = e * (1.0 - e.zxy);\\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n      vec3 d1 = d0 - (i1 - K2);\\n      vec3 d2 = d0 - (i2 - K1);\\n      vec3 d3 = d0 - 0.5;\\n      vec4 h = max(0.6 - vec4(\\n        dot(d0, d0),\\n        dot(d1, d1),\\n        dot(d2, d2),\\n        dot(d3, d3)\\n      ), 0.0);\\n      vec4 n = h * h * h * h * vec4(\\n        dot(d0, hash33(i)),\\n        dot(d1, hash33(i + i1)),\\n        dot(d2, hash33(i + i2)),\\n        dot(d3, hash33(i + 1.0))\\n      );\\n      return dot(vec4(31.316), n);\\n    }\\n\\n    vec4 extractAlpha(vec3 colorIn) {\\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\\n      return vec4(colorIn.rgb / (a + 1e-5), a);\\n    }\\n\\n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\\n    const float innerRadius = 0.6;\\n    const float noiseScale = 0.65;\\n\\n    float light1(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * attenuation);\\n    }\\n    float light2(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * dist * attenuation);\\n    }\\n\\n    vec4 draw(vec2 uv) {\\n      float ang = atan(uv.y, uv.x);\\n      float len = length(uv);\\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\\n      \\n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\\n      float d0 = distance(uv, (r0 * invLen) * uv);\\n      float v0 = light1(1.0, 10.0, d0);\\n      v0 *= smoothstep(r0 * 1.05, r0, len);\\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\\n      \\n      float a = iTime * -1.0;\\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\\n      float d = distance(uv, pos);\\n      float v1 = light2(1.5, 5.0, d);\\n      v1 *= light1(1.0, 50.0, d0);\\n      \\n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\\n      \\n      vec3 finalColor;\\n\\n      if (hasTexture > 0.5) {\\n        // Use Avatar as the base color\\n        vec2 avatarUV = uv * 0.5 + 0.5;\\n        vec3 avatarColor = texture2D(tMap, avatarUV).rgb;\\n        \\n        // Get procedural colors for tinting and effects\\n        vec3 color1 = adjustHue(baseColor1, hue);\\n        vec3 color2 = adjustHue(baseColor2, hue);\\n        vec3 color3 = adjustHue(baseColor3, hue);\\n        \\n        vec3 tint = mix(color1, color2, cl);\\n        tint = mix(color3, tint, v0);\\n        \\n        // Blend the avatar with the procedural tint and add highlights\\n        finalColor = mix(avatarColor, tint, 0.4);\\n        finalColor += v1 * 0.8; \\n      } else {\\n        // Fallback to original procedural orb if no texture\\n        vec3 color1 = adjustHue(baseColor1, hue);\\n        vec3 color2 = adjustHue(baseColor2, hue);\\n        vec3 color3 = adjustHue(baseColor3, hue);\\n        vec3 col = mix(color1, color2, cl);\\n        col = mix(color3, col, v0);\\n        finalColor = (col + v1);\\n      }\\n      \\n      // Add a glowing edge (fresnel effect)\\n      float fresnel = smoothstep(0.7, 1.0, len) * 0.5;\\n      finalColor += fresnel;\\n\\n      // Apply the main orb shape and clamp colors\\n      finalColor *= v2 * v3;\\n      finalColor = clamp(finalColor, 0.0, 1.0);\\n      \\n      return extractAlpha(finalColor);\\n    }\\n\\n    vec4 mainImage(vec2 fragCoord) {\\n      vec2 center = iResolution.xy * 0.5;\\n      float size = min(iResolution.x, iResolution.y);\\n      vec2 uv = (fragCoord - center) / size * 2.0;\\n      \\n      float angle = rot;\\n      float s = sin(angle);\\n      float c = cos(angle);\\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\\n      \\n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\\n      \\n      return draw(uv);\\n    }\\n\\n    void main() {\\n      vec2 fragCoord = vUv * iResolution.xy;\\n      vec4 col = mainImage(fragCoord);\\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\\n    }\\n  \";\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Orb.useEffect\": ()=>{\n            const container = ctnDom.current;\n            if (!container) return;\n            const renderer = new ogl__WEBPACK_IMPORTED_MODULE_3__.Renderer({\n                alpha: true,\n                premultipliedAlpha: false\n            });\n            const gl = renderer.gl;\n            gl.clearColor(0, 0, 0, 0);\n            container.appendChild(gl.canvas);\n            const texture = new ogl__WEBPACK_IMPORTED_MODULE_4__.Texture(gl);\n            if (avatarUrl) {\n                const img = new Image();\n                img.crossOrigin = \"anonymous\";\n                img.src = avatarUrl;\n                img.onload = ({\n                    \"Orb.useEffect\": ()=>{\n                        texture.image = img;\n                    }\n                })[\"Orb.useEffect\"];\n            }\n            const geometry = new ogl__WEBPACK_IMPORTED_MODULE_5__.Triangle(gl);\n            const program = new ogl__WEBPACK_IMPORTED_MODULE_6__.Program(gl, {\n                vertex: vert,\n                fragment: frag,\n                uniforms: {\n                    iTime: {\n                        value: 0\n                    },\n                    iResolution: {\n                        value: new ogl__WEBPACK_IMPORTED_MODULE_7__.Vec3(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n                    },\n                    hue: {\n                        value: hue\n                    },\n                    hover: {\n                        value: 0\n                    },\n                    rot: {\n                        value: 0\n                    },\n                    hoverIntensity: {\n                        value: hoverIntensity\n                    },\n                    tMap: {\n                        value: texture\n                    },\n                    hasTexture: {\n                        value: avatarUrl ? 1.0 : 0.0\n                    }\n                }\n            });\n            const mesh = new ogl__WEBPACK_IMPORTED_MODULE_8__.Mesh(gl, {\n                geometry,\n                program\n            });\n            function resize() {\n                if (!container) return;\n                const dpr = window.devicePixelRatio || 1;\n                const width = container.clientWidth;\n                const height = container.clientHeight;\n                renderer.setSize(width * dpr, height * dpr);\n                gl.canvas.style.width = width + \"px\";\n                gl.canvas.style.height = height + \"px\";\n                program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height);\n            }\n            window.addEventListener(\"resize\", resize);\n            resize();\n            let targetHover = 0;\n            let lastTime = 0;\n            let currentRot = 0;\n            const rotationSpeed = 0.3;\n            const handleMouseMove = {\n                \"Orb.useEffect.handleMouseMove\": (e)=>{\n                    if (!container) return;\n                    const rect = container.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    const width = rect.width;\n                    const height = rect.height;\n                    const size = Math.min(width, height);\n                    const centerX = width / 2;\n                    const centerY = height / 2;\n                    const uvX = (x - centerX) / size * 2.0;\n                    const uvY = (y - centerY) / size * 2.0;\n                    if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n                        targetHover = 1;\n                    } else {\n                        targetHover = 0;\n                    }\n                }\n            }[\"Orb.useEffect.handleMouseMove\"];\n            const handleMouseLeave = {\n                \"Orb.useEffect.handleMouseLeave\": ()=>{\n                    targetHover = 0;\n                }\n            }[\"Orb.useEffect.handleMouseLeave\"];\n            container.addEventListener(\"mousemove\", handleMouseMove);\n            container.addEventListener(\"mouseleave\", handleMouseLeave);\n            let rafId;\n            const update = {\n                \"Orb.useEffect.update\": (t)=>{\n                    rafId = requestAnimationFrame(update);\n                    const dt = (t - lastTime) * 0.001;\n                    lastTime = t;\n                    program.uniforms.iTime.value = t * 0.001;\n                    program.uniforms.hue.value = hue;\n                    program.uniforms.hoverIntensity.value = hoverIntensity;\n                    const effectiveHover = forceHoverState ? 1 : targetHover;\n                    program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n                    if (rotateOnHover && effectiveHover > 0.5) {\n                        currentRot += dt * rotationSpeed;\n                    }\n                    program.uniforms.rot.value = currentRot;\n                    renderer.render({\n                        scene: mesh\n                    });\n                }\n            }[\"Orb.useEffect.update\"];\n            rafId = requestAnimationFrame(update);\n            return ({\n                \"Orb.useEffect\": ()=>{\n                    var _gl_getExtension;\n                    if (rafId) cancelAnimationFrame(rafId);\n                    window.removeEventListener(\"resize\", resize);\n                    if (container) {\n                        container.removeEventListener(\"mousemove\", handleMouseMove);\n                        container.removeEventListener(\"mouseleave\", handleMouseLeave);\n                        if (gl.canvas.parentNode === container) {\n                            container.removeChild(gl.canvas);\n                        }\n                    }\n                    (_gl_getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl_getExtension === void 0 ? void 0 : _gl_getExtension.loseContext();\n                }\n            })[\"Orb.useEffect\"];\n        }\n    }[\"Orb.useEffect\"], [\n        avatarUrl,\n        hue,\n        hoverIntensity,\n        rotateOnHover,\n        forceHoverState\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ctnDom,\n        className: \"orb-container\"\n    }, void 0, false, {\n        fileName: \"/Users/yangjunci/Documents/GitHub/fuyun-dev-website/components/Orb.tsx\",\n        lineNumber: 337,\n        columnNumber: 10\n    }, this);\n}\n_s(Orb, \"RK9NRNXyqwE64a4o6Ka2phRjmok=\");\n_c = Orb;\nvar _c;\n$RefreshReg$(_c, \"Orb\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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M1V3QnpGO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMveWFuZ2p1bmNpL0RvY3VtZW50cy9HaXRIdWIvZnV5dW4tZGV2LXdlYnNpdGUvY29tcG9uZW50cy9PcmIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFJlbmRlcmVyLCBQcm9ncmFtLCBNZXNoLCBUcmlhbmdsZSwgVmVjMywgVGV4dHVyZSB9IGZyb20gXCJvZ2xcIjtcblxuaW1wb3J0IFwiLi9PcmIuY3NzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9yYih7XG4gIGh1ZSA9IDAsXG4gIGhvdmVySW50ZW5zaXR5ID0gMC4yLFxuICByb3RhdGVPbkhvdmVyID0gdHJ1ZSxcbiAgZm9yY2VIb3ZlclN0YXRlID0gZmFsc2UsXG4gIGF2YXRhclVybCxcbn06IHtcbiAgaHVlPzogbnVtYmVyO1xuICBob3ZlckludGVuc2l0eT86IG51bWJlcjtcbiAgcm90YXRlT25Ib3Zlcj86IGJvb2xlYW47XG4gIGZvcmNlSG92ZXJTdGF0ZT86IGJvb2xlYW47XG4gIGF2YXRhclVybD86IHN0cmluZztcbn0pIHtcbiAgY29uc3QgY3RuRG9tID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblxuICBjb25zdCB2ZXJ0ID0gLyogZ2xzbCAqLyBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICB9XG4gIGA7XG5cbiAgY29uc3QgZnJhZyA9IC8qIGdsc2wgKi8gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gZmxvYXQgaVRpbWU7XG4gICAgdW5pZm9ybSB2ZWMzIGlSZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgaHVlO1xuICAgIHVuaWZvcm0gZmxvYXQgaG92ZXI7XG4gICAgdW5pZm9ybSBmbG9hdCByb3Q7XG4gICAgdW5pZm9ybSBmbG9hdCBob3ZlckludGVuc2l0eTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB0TWFwO1xuICAgIHVuaWZvcm0gZmxvYXQgaGFzVGV4dHVyZTtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdmVjMyByZ2IyeWlxKHZlYzMgYykge1xuICAgICAgZmxvYXQgeSA9IGRvdChjLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcbiAgICAgIGZsb2F0IGkgPSBkb3QoYywgdmVjMygwLjU5NiwgLTAuMjc0LCAtMC4zMjIpKTtcbiAgICAgIGZsb2F0IHEgPSBkb3QoYywgdmVjMygwLjIxMSwgLTAuNTIzLCAwLjMxMikpO1xuICAgICAgcmV0dXJuIHZlYzMoeSwgaSwgcSk7XG4gICAgfVxuICAgIFxuICAgIHZlYzMgeWlxMnJnYih2ZWMzIGMpIHtcbiAgICAgIGZsb2F0IHIgPSBjLnggKyAwLjk1NiAqIGMueSArIDAuNjIxICogYy56O1xuICAgICAgZmxvYXQgZyA9IGMueCAtIDAuMjcyICogYy55IC0gMC42NDcgKiBjLno7XG4gICAgICBmbG9hdCBiID0gYy54IC0gMS4xMDYgKiBjLnkgKyAxLjcwMyAqIGMuejtcbiAgICAgIHJldHVybiB2ZWMzKHIsIGcsIGIpO1xuICAgIH1cbiAgICBcbiAgICB2ZWMzIGFkanVzdEh1ZSh2ZWMzIGNvbG9yLCBmbG9hdCBodWVEZWcpIHtcbiAgICAgIGZsb2F0IGh1ZVJhZCA9IGh1ZURlZyAqIDMuMTQxNTkyNjUgLyAxODAuMDtcbiAgICAgIHZlYzMgeWlxID0gcmdiMnlpcShjb2xvcik7XG4gICAgICBmbG9hdCBjb3NBID0gY29zKGh1ZVJhZCk7XG4gICAgICBmbG9hdCBzaW5BID0gc2luKGh1ZVJhZCk7XG4gICAgICBmbG9hdCBpID0geWlxLnkgKiBjb3NBIC0geWlxLnogKiBzaW5BO1xuICAgICAgZmxvYXQgcSA9IHlpcS55ICogc2luQSArIHlpcS56ICogY29zQTtcbiAgICAgIHlpcS55ID0gaTtcbiAgICAgIHlpcS56ID0gcTtcbiAgICAgIHJldHVybiB5aXEycmdiKHlpcSk7XG4gICAgfVxuXG4gICAgdmVjMyBoYXNoMzModmVjMyBwMykge1xuICAgICAgcDMgPSBmcmFjdChwMyAqIHZlYzMoMC4xMDMxLCAwLjExMzY5LCAwLjEzNzg3KSk7XG4gICAgICBwMyArPSBkb3QocDMsIHAzLnl4eiArIDE5LjE5KTtcbiAgICAgIHJldHVybiAtMS4wICsgMi4wICogZnJhY3QodmVjMyhcbiAgICAgICAgcDMueCArIHAzLnksXG4gICAgICAgIHAzLnggKyBwMy56LFxuICAgICAgICBwMy55ICsgcDMuelxuICAgICAgKSAqIHAzLnp5eCk7XG4gICAgfVxuXG4gICAgZmxvYXQgc25vaXNlMyh2ZWMzIHApIHtcbiAgICAgIGNvbnN0IGZsb2F0IEsxID0gMC4zMzMzMzMzMzM7XG4gICAgICBjb25zdCBmbG9hdCBLMiA9IDAuMTY2NjY2NjY3O1xuICAgICAgdmVjMyBpID0gZmxvb3IocCArIChwLnggKyBwLnkgKyBwLnopICogSzEpO1xuICAgICAgdmVjMyBkMCA9IHAgLSAoaSAtIChpLnggKyBpLnkgKyBpLnopICogSzIpO1xuICAgICAgdmVjMyBlID0gc3RlcCh2ZWMzKDAuMCksIGQwIC0gZDAueXp4KTtcbiAgICAgIHZlYzMgaTEgPSBlICogKDEuMCAtIGUuenh5KTtcbiAgICAgIHZlYzMgaTIgPSAxLjAgLSBlLnp4eSAqICgxLjAgLSBlKTtcbiAgICAgIHZlYzMgZDEgPSBkMCAtIChpMSAtIEsyKTtcbiAgICAgIHZlYzMgZDIgPSBkMCAtIChpMiAtIEsxKTtcbiAgICAgIHZlYzMgZDMgPSBkMCAtIDAuNTtcbiAgICAgIHZlYzQgaCA9IG1heCgwLjYgLSB2ZWM0KFxuICAgICAgICBkb3QoZDAsIGQwKSxcbiAgICAgICAgZG90KGQxLCBkMSksXG4gICAgICAgIGRvdChkMiwgZDIpLFxuICAgICAgICBkb3QoZDMsIGQzKVxuICAgICAgKSwgMC4wKTtcbiAgICAgIHZlYzQgbiA9IGggKiBoICogaCAqIGggKiB2ZWM0KFxuICAgICAgICBkb3QoZDAsIGhhc2gzMyhpKSksXG4gICAgICAgIGRvdChkMSwgaGFzaDMzKGkgKyBpMSkpLFxuICAgICAgICBkb3QoZDIsIGhhc2gzMyhpICsgaTIpKSxcbiAgICAgICAgZG90KGQzLCBoYXNoMzMoaSArIDEuMCkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvdCh2ZWM0KDMxLjMxNiksIG4pO1xuICAgIH1cblxuICAgIHZlYzQgZXh0cmFjdEFscGhhKHZlYzMgY29sb3JJbikge1xuICAgICAgZmxvYXQgYSA9IG1heChtYXgoY29sb3JJbi5yLCBjb2xvckluLmcpLCBjb2xvckluLmIpO1xuICAgICAgcmV0dXJuIHZlYzQoY29sb3JJbi5yZ2IgLyAoYSArIDFlLTUpLCBhKTtcbiAgICB9XG5cbiAgICBjb25zdCB2ZWMzIGJhc2VDb2xvcjEgPSB2ZWMzKDAuNjExNzY1LCAwLjI2Mjc0NSwgMC45OTYwNzgpO1xuICAgIGNvbnN0IHZlYzMgYmFzZUNvbG9yMiA9IHZlYzMoMC4yOTgwMzksIDAuNzYwNzg0LCAwLjkxMzcyNSk7XG4gICAgY29uc3QgdmVjMyBiYXNlQ29sb3IzID0gdmVjMygwLjA2Mjc0NSwgMC4wNzg0MzEsIDAuNjAwMDAwKTtcbiAgICBjb25zdCBmbG9hdCBpbm5lclJhZGl1cyA9IDAuNjtcbiAgICBjb25zdCBmbG9hdCBub2lzZVNjYWxlID0gMC42NTtcblxuICAgIGZsb2F0IGxpZ2h0MShmbG9hdCBpbnRlbnNpdHksIGZsb2F0IGF0dGVudWF0aW9uLCBmbG9hdCBkaXN0KSB7XG4gICAgICByZXR1cm4gaW50ZW5zaXR5IC8gKDEuMCArIGRpc3QgKiBhdHRlbnVhdGlvbik7XG4gICAgfVxuICAgIGZsb2F0IGxpZ2h0MihmbG9hdCBpbnRlbnNpdHksIGZsb2F0IGF0dGVudWF0aW9uLCBmbG9hdCBkaXN0KSB7XG4gICAgICByZXR1cm4gaW50ZW5zaXR5IC8gKDEuMCArIGRpc3QgKiBkaXN0ICogYXR0ZW51YXRpb24pO1xuICAgIH1cblxuICAgIHZlYzQgZHJhdyh2ZWMyIHV2KSB7XG4gICAgICBmbG9hdCBhbmcgPSBhdGFuKHV2LnksIHV2LngpO1xuICAgICAgZmxvYXQgbGVuID0gbGVuZ3RoKHV2KTtcbiAgICAgIGZsb2F0IGludkxlbiA9IGxlbiA+IDAuMCA/IDEuMCAvIGxlbiA6IDAuMDtcbiAgICAgIFxuICAgICAgZmxvYXQgbjAgPSBzbm9pc2UzKHZlYzModXYgKiBub2lzZVNjYWxlLCBpVGltZSAqIDAuNSkpICogMC41ICsgMC41O1xuICAgICAgZmxvYXQgcjAgPSBtaXgobWl4KGlubmVyUmFkaXVzLCAxLjAsIDAuNCksIG1peChpbm5lclJhZGl1cywgMS4wLCAwLjYpLCBuMCk7XG4gICAgICBmbG9hdCBkMCA9IGRpc3RhbmNlKHV2LCAocjAgKiBpbnZMZW4pICogdXYpO1xuICAgICAgZmxvYXQgdjAgPSBsaWdodDEoMS4wLCAxMC4wLCBkMCk7XG4gICAgICB2MCAqPSBzbW9vdGhzdGVwKHIwICogMS4wNSwgcjAsIGxlbik7XG4gICAgICBmbG9hdCBjbCA9IGNvcyhhbmcgKyBpVGltZSAqIDIuMCkgKiAwLjUgKyAwLjU7XG4gICAgICBcbiAgICAgIGZsb2F0IGEgPSBpVGltZSAqIC0xLjA7XG4gICAgICB2ZWMyIHBvcyA9IHZlYzIoY29zKGEpLCBzaW4oYSkpICogcjA7XG4gICAgICBmbG9hdCBkID0gZGlzdGFuY2UodXYsIHBvcyk7XG4gICAgICBmbG9hdCB2MSA9IGxpZ2h0MigxLjUsIDUuMCwgZCk7XG4gICAgICB2MSAqPSBsaWdodDEoMS4wLCA1MC4wLCBkMCk7XG4gICAgICBcbiAgICAgIGZsb2F0IHYyID0gc21vb3Roc3RlcCgxLjAsIG1peChpbm5lclJhZGl1cywgMS4wLCBuMCAqIDAuNSksIGxlbik7XG4gICAgICBmbG9hdCB2MyA9IHNtb290aHN0ZXAoaW5uZXJSYWRpdXMsIG1peChpbm5lclJhZGl1cywgMS4wLCAwLjUpLCBsZW4pO1xuICAgICAgXG4gICAgICB2ZWMzIGZpbmFsQ29sb3I7XG5cbiAgICAgIGlmIChoYXNUZXh0dXJlID4gMC41KSB7XG4gICAgICAgIC8vIFVzZSBBdmF0YXIgYXMgdGhlIGJhc2UgY29sb3JcbiAgICAgICAgdmVjMiBhdmF0YXJVViA9IHV2ICogMC41ICsgMC41O1xuICAgICAgICB2ZWMzIGF2YXRhckNvbG9yID0gdGV4dHVyZTJEKHRNYXAsIGF2YXRhclVWKS5yZ2I7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgcHJvY2VkdXJhbCBjb2xvcnMgZm9yIHRpbnRpbmcgYW5kIGVmZmVjdHNcbiAgICAgICAgdmVjMyBjb2xvcjEgPSBhZGp1c3RIdWUoYmFzZUNvbG9yMSwgaHVlKTtcbiAgICAgICAgdmVjMyBjb2xvcjIgPSBhZGp1c3RIdWUoYmFzZUNvbG9yMiwgaHVlKTtcbiAgICAgICAgdmVjMyBjb2xvcjMgPSBhZGp1c3RIdWUoYmFzZUNvbG9yMywgaHVlKTtcbiAgICAgICAgXG4gICAgICAgIHZlYzMgdGludCA9IG1peChjb2xvcjEsIGNvbG9yMiwgY2wpO1xuICAgICAgICB0aW50ID0gbWl4KGNvbG9yMywgdGludCwgdjApO1xuICAgICAgICBcbiAgICAgICAgLy8gQmxlbmQgdGhlIGF2YXRhciB3aXRoIHRoZSBwcm9jZWR1cmFsIHRpbnQgYW5kIGFkZCBoaWdobGlnaHRzXG4gICAgICAgIGZpbmFsQ29sb3IgPSBtaXgoYXZhdGFyQ29sb3IsIHRpbnQsIDAuNCk7XG4gICAgICAgIGZpbmFsQ29sb3IgKz0gdjEgKiAwLjg7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gb3JpZ2luYWwgcHJvY2VkdXJhbCBvcmIgaWYgbm8gdGV4dHVyZVxuICAgICAgICB2ZWMzIGNvbG9yMSA9IGFkanVzdEh1ZShiYXNlQ29sb3IxLCBodWUpO1xuICAgICAgICB2ZWMzIGNvbG9yMiA9IGFkanVzdEh1ZShiYXNlQ29sb3IyLCBodWUpO1xuICAgICAgICB2ZWMzIGNvbG9yMyA9IGFkanVzdEh1ZShiYXNlQ29sb3IzLCBodWUpO1xuICAgICAgICB2ZWMzIGNvbCA9IG1peChjb2xvcjEsIGNvbG9yMiwgY2wpO1xuICAgICAgICBjb2wgPSBtaXgoY29sb3IzLCBjb2wsIHYwKTtcbiAgICAgICAgZmluYWxDb2xvciA9IChjb2wgKyB2MSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIGdsb3dpbmcgZWRnZSAoZnJlc25lbCBlZmZlY3QpXG4gICAgICBmbG9hdCBmcmVzbmVsID0gc21vb3Roc3RlcCgwLjcsIDEuMCwgbGVuKSAqIDAuNTtcbiAgICAgIGZpbmFsQ29sb3IgKz0gZnJlc25lbDtcblxuICAgICAgLy8gQXBwbHkgdGhlIG1haW4gb3JiIHNoYXBlIGFuZCBjbGFtcCBjb2xvcnNcbiAgICAgIGZpbmFsQ29sb3IgKj0gdjIgKiB2MztcbiAgICAgIGZpbmFsQ29sb3IgPSBjbGFtcChmaW5hbENvbG9yLCAwLjAsIDEuMCk7XG4gICAgICBcbiAgICAgIHJldHVybiBleHRyYWN0QWxwaGEoZmluYWxDb2xvcik7XG4gICAgfVxuXG4gICAgdmVjNCBtYWluSW1hZ2UodmVjMiBmcmFnQ29vcmQpIHtcbiAgICAgIHZlYzIgY2VudGVyID0gaVJlc29sdXRpb24ueHkgKiAwLjU7XG4gICAgICBmbG9hdCBzaXplID0gbWluKGlSZXNvbHV0aW9uLngsIGlSZXNvbHV0aW9uLnkpO1xuICAgICAgdmVjMiB1diA9IChmcmFnQ29vcmQgLSBjZW50ZXIpIC8gc2l6ZSAqIDIuMDtcbiAgICAgIFxuICAgICAgZmxvYXQgYW5nbGUgPSByb3Q7XG4gICAgICBmbG9hdCBzID0gc2luKGFuZ2xlKTtcbiAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGUpO1xuICAgICAgdXYgPSB2ZWMyKGMgKiB1di54IC0gcyAqIHV2LnksIHMgKiB1di54ICsgYyAqIHV2LnkpO1xuICAgICAgXG4gICAgICB1di54ICs9IGhvdmVyICogaG92ZXJJbnRlbnNpdHkgKiAwLjEgKiBzaW4odXYueSAqIDEwLjAgKyBpVGltZSk7XG4gICAgICB1di55ICs9IGhvdmVyICogaG92ZXJJbnRlbnNpdHkgKiAwLjEgKiBzaW4odXYueCAqIDEwLjAgKyBpVGltZSk7XG4gICAgICBcbiAgICAgIHJldHVybiBkcmF3KHV2KTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIGZyYWdDb29yZCA9IHZVdiAqIGlSZXNvbHV0aW9uLnh5O1xuICAgICAgdmVjNCBjb2wgPSBtYWluSW1hZ2UoZnJhZ0Nvb3JkKTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLnJnYiAqIGNvbC5hLCBjb2wuYSk7XG4gICAgfVxuICBgO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY3RuRG9tLmN1cnJlbnQ7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHsgYWxwaGE6IHRydWUsIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UgfSk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChnbC5jYW52YXMpO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsKTtcbiAgICBpZiAoYXZhdGFyVXJsKSB7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICBpbWcuc3JjID0gYXZhdGFyVXJsO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVHJpYW5nbGUoZ2wpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwge1xuICAgICAgdmVydGV4OiB2ZXJ0LFxuICAgICAgZnJhZ21lbnQ6IGZyYWcsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpVGltZTogeyB2YWx1ZTogMCB9LFxuICAgICAgICBpUmVzb2x1dGlvbjoge1xuICAgICAgICAgIHZhbHVlOiBuZXcgVmVjMyhcbiAgICAgICAgICAgIGdsLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGdsLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBnbC5jYW52YXMud2lkdGggLyBnbC5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgKSxcbiAgICAgICAgfSxcbiAgICAgICAgaHVlOiB7IHZhbHVlOiBodWUgfSxcbiAgICAgICAgaG92ZXI6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgcm90OiB7IHZhbHVlOiAwIH0sXG4gICAgICAgIGhvdmVySW50ZW5zaXR5OiB7IHZhbHVlOiBob3ZlckludGVuc2l0eSB9LFxuICAgICAgICB0TWFwOiB7IHZhbHVlOiB0ZXh0dXJlIH0sXG4gICAgICAgIGhhc1RleHR1cmU6IHsgdmFsdWU6IGF2YXRhclVybCA/IDEuMCA6IDAuMCB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnbCwgeyBnZW9tZXRyeSwgcHJvZ3JhbSB9KTtcblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGdsLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaVJlc29sdXRpb24udmFsdWUuc2V0KFxuICAgICAgICBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgIGdsLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgIGdsLmNhbnZhcy53aWR0aCAvIGdsLmNhbnZhcy5oZWlnaHRcbiAgICAgICk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZSk7XG4gICAgcmVzaXplKCk7XG5cbiAgICBsZXQgdGFyZ2V0SG92ZXIgPSAwO1xuICAgIGxldCBsYXN0VGltZSA9IDA7XG4gICAgbGV0IGN1cnJlbnRSb3QgPSAwO1xuICAgIGNvbnN0IHJvdGF0aW9uU3BlZWQgPSAwLjM7XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gd2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDI7XG4gICAgICBjb25zdCB1dlggPSAoKHggLSBjZW50ZXJYKSAvIHNpemUpICogMi4wO1xuICAgICAgY29uc3QgdXZZID0gKCh5IC0gY2VudGVyWSkgLyBzaXplKSAqIDIuMDtcblxuICAgICAgaWYgKE1hdGguc3FydCh1dlggKiB1dlggKyB1dlkgKiB1dlkpIDwgMC44KSB7XG4gICAgICAgIHRhcmdldEhvdmVyID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEhvdmVyID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICAgIHRhcmdldEhvdmVyID0gMDtcbiAgICB9O1xuXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlTW91c2VMZWF2ZSk7XG5cbiAgICBsZXQgcmFmSWQ6IG51bWJlcjtcbiAgICBjb25zdCB1cGRhdGUgPSAodDogbnVtYmVyKSA9PiB7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuICAgICAgY29uc3QgZHQgPSAodCAtIGxhc3RUaW1lKSAqIDAuMDAxO1xuICAgICAgbGFzdFRpbWUgPSB0O1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5pVGltZS52YWx1ZSA9IHQgKiAwLjAwMTtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaHVlLnZhbHVlID0gaHVlO1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5ob3ZlckludGVuc2l0eS52YWx1ZSA9IGhvdmVySW50ZW5zaXR5O1xuXG4gICAgICBjb25zdCBlZmZlY3RpdmVIb3ZlciA9IGZvcmNlSG92ZXJTdGF0ZSA/IDEgOiB0YXJnZXRIb3ZlcjtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaG92ZXIudmFsdWUgKz1cbiAgICAgICAgKGVmZmVjdGl2ZUhvdmVyIC0gcHJvZ3JhbS51bmlmb3Jtcy5ob3Zlci52YWx1ZSkgKiAwLjE7XG5cbiAgICAgIGlmIChyb3RhdGVPbkhvdmVyICYmIGVmZmVjdGl2ZUhvdmVyID4gMC41KSB7XG4gICAgICAgIGN1cnJlbnRSb3QgKz0gZHQgKiByb3RhdGlvblNwZWVkO1xuICAgICAgfVxuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5yb3QudmFsdWUgPSBjdXJyZW50Um90O1xuXG4gICAgICByZW5kZXJlci5yZW5kZXIoeyBzY2VuZTogbWVzaCB9KTtcbiAgICB9O1xuICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHJhZklkKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemUpO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlTW91c2VMZWF2ZSk7XG4gICAgICAgIGlmIChnbC5jYW52YXMucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGdsLmNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKT8ubG9zZUNvbnRleHQoKTtcbiAgICB9O1xuICB9LCBbYXZhdGFyVXJsLCBodWUsIGhvdmVySW50ZW5zaXR5LCByb3RhdGVPbkhvdmVyLCBmb3JjZUhvdmVyU3RhdGVdKTtcblxuICByZXR1cm4gPGRpdiByZWY9e2N0bkRvbX0gY2xhc3NOYW1lPVwib3JiLWNvbnRhaW5lclwiIC8+O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlJlbmRlcmVyIiwiUHJvZ3JhbSIsIk1lc2giLCJUcmlhbmdsZSIsIlZlYzMiLCJUZXh0dXJlIiwiT3JiIiwiaHVlIiwiaG92ZXJJbnRlbnNpdHkiLCJyb3RhdGVPbkhvdmVyIiwiZm9yY2VIb3ZlclN0YXRlIiwiYXZhdGFyVXJsIiwiY3RuRG9tIiwidmVydCIsImZyYWciLCJjb250YWluZXIiLCJjdXJyZW50IiwicmVuZGVyZXIiLCJhbHBoYSIsInByZW11bHRpcGxpZWRBbHBoYSIsImdsIiwiY2xlYXJDb2xvciIsImFwcGVuZENoaWxkIiwiY2FudmFzIiwidGV4dHVyZSIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJzcmMiLCJvbmxvYWQiLCJpbWFnZSIsImdlb21ldHJ5IiwicHJvZ3JhbSIsInZlcnRleCIsImZyYWdtZW50IiwidW5pZm9ybXMiLCJpVGltZSIsInZhbHVlIiwiaVJlc29sdXRpb24iLCJ3aWR0aCIsImhlaWdodCIsImhvdmVyIiwicm90IiwidE1hcCIsImhhc1RleHR1cmUiLCJtZXNoIiwicmVzaXplIiwiZHByIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2V0U2l6ZSIsInN0eWxlIiwic2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInRhcmdldEhvdmVyIiwibGFzdFRpbWUiLCJjdXJyZW50Um90Iiwicm90YXRpb25TcGVlZCIsImhhbmRsZU1vdXNlTW92ZSIsImUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJsZWZ0IiwieSIsImNsaWVudFkiLCJ0b3AiLCJzaXplIiwiTWF0aCIsIm1pbiIsImNlbnRlclgiLCJjZW50ZXJZIiwidXZYIiwidXZZIiwic3FydCIsImhhbmRsZU1vdXNlTGVhdmUiLCJyYWZJZCIsInVwZGF0ZSIsInQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkdCIsImVmZmVjdGl2ZUhvdmVyIiwicmVuZGVyIiwic2NlbmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJnZXRFeHRlbnNpb24iLCJsb3NlQ29udGV4dCIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Orb.tsx\n"));

/***/ })

});