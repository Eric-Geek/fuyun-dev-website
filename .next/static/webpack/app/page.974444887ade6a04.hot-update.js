"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Orb.tsx":
/*!****************************!*\
  !*** ./components/Orb.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Orb)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Texture.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/math/Vec3.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Mesh.js\");\n/* harmony import */ var _Orb_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Orb.css */ \"(app-pages-browser)/./components/Orb.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction Orb(param) {\n    let { hue = 0, hoverIntensity = 0.2, rotateOnHover = true, forceHoverState = false, avatarUrl } = param;\n    _s();\n    const ctnDom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const vert = \"\\n    precision highp float;\\n    attribute vec2 position;\\n    attribute vec2 uv;\\n    varying vec2 vUv;\\n    void main() {\\n      vUv = uv;\\n      gl_Position = vec4(position, 0.0, 1.0);\\n    }\\n  \";\n    const frag = \"\\n    precision highp float;\\n\\n    uniform float iTime;\\n    uniform vec3 iResolution;\\n    uniform float hue;\\n    uniform float hover;\\n    uniform float rot;\\n    uniform float hoverIntensity;\\n    uniform sampler2D tMap;\\n    uniform float hasTexture;\\n    varying vec2 vUv;\\n\\n    vec3 rgb2yiq(vec3 c) {\\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\\n      return vec3(y, i, q);\\n    }\\n    \\n    vec3 yiq2rgb(vec3 c) {\\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\\n      return vec3(r, g, b);\\n    }\\n    \\n    vec3 adjustHue(vec3 color, float hueDeg) {\\n      float hueRad = hueDeg * 3.14159265 / 180.0;\\n      vec3 yiq = rgb2yiq(color);\\n      float cosA = cos(hueRad);\\n      float sinA = sin(hueRad);\\n      float i = yiq.y * cosA - yiq.z * sinA;\\n      float q = yiq.y * sinA + yiq.z * cosA;\\n      yiq.y = i;\\n      yiq.z = q;\\n      return yiq2rgb(yiq);\\n    }\\n\\n    vec3 hash33(vec3 p3) {\\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\\n      p3 += dot(p3, p3.yxz + 19.19);\\n      return -1.0 + 2.0 * fract(vec3(\\n        p3.x + p3.y,\\n        p3.x + p3.z,\\n        p3.y + p3.z\\n      ) * p3.zyx);\\n    }\\n\\n    float snoise3(vec3 p) {\\n      const float K1 = 0.333333333;\\n      const float K2 = 0.166666667;\\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n      vec3 i1 = e * (1.0 - e.zxy);\\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n      vec3 d1 = d0 - (i1 - K2);\\n      vec3 d2 = d0 - (i2 - K1);\\n      vec3 d3 = d0 - 0.5;\\n      vec4 h = max(0.6 - vec4(\\n        dot(d0, d0),\\n        dot(d1, d1),\\n        dot(d2, d2),\\n        dot(d3, d3)\\n      ), 0.0);\\n      vec4 n = h * h * h * h * vec4(\\n        dot(d0, hash33(i)),\\n        dot(d1, hash33(i + i1)),\\n        dot(d2, hash33(i + i2)),\\n        dot(d3, hash33(i + 1.0))\\n      );\\n      return dot(vec4(31.316), n);\\n    }\\n\\n    vec4 extractAlpha(vec3 colorIn) {\\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\\n      return vec4(colorIn.rgb / (a + 1e-5), a);\\n    }\\n\\n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\\n    const float innerRadius = 0.6;\\n    const float noiseScale = 0.65;\\n\\n    float light1(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * attenuation);\\n    }\\n    float light2(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * dist * attenuation);\\n    }\\n\\n    vec4 draw(vec2 uv) {\\n      vec3 color1 = adjustHue(baseColor1, hue);\\n      vec3 color2 = adjustHue(baseColor2, hue);\\n      vec3 color3 = adjustHue(baseColor3, hue);\\n      \\n      float ang = atan(uv.y, uv.x);\\n      float len = length(uv);\\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\\n      \\n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\\n      float d0 = distance(uv, (r0 * invLen) * uv);\\n      float v0 = light1(1.0, 10.0, d0);\\n      v0 *= smoothstep(r0 * 1.05, r0, len);\\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\\n      \\n      float a = iTime * -1.0;\\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\\n      float d = distance(uv, pos);\\n      float v1 = light2(1.5, 5.0, d);\\n      v1 *= light1(1.0, 50.0, d0);\\n      \\n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\\n      \\n      vec3 col = mix(color1, color2, cl);\\n      col = mix(color3, col, v0);\\n      col = (col + v1) * v2 * v3;\\n      col = clamp(col, 0.0, 1.0);\\n      \\n      vec4 orbColor = extractAlpha(col);\\n\\n      if (hasTexture > 0.5) {\\n        float avatarRadius = 0.5;\\n        float dist = length(uv);\\n\\n        // Create a smooth circular mask for the avatar\\n        float avatarMask = 1.0 - smoothstep(avatarRadius, avatarRadius + 0.05, dist);\\n\\n        if (avatarMask > 0.0) {\\n            // Map UVs to sample the texture correctly within the circle\\n            vec2 avatarUV = uv / avatarRadius * 0.5 + 0.5;\\n            vec4 avatarTexColor = texture2D(tMap, avatarUV);\\n\\n            // Blend avatar with the orb's color for a 'fused' look\\n            vec3 blendedAvatar = mix(avatarTexColor.rgb, orbColor.rgb, 0.4);\\n\\n            // Now place the blended avatar into the main orb using the mask\\n            vec3 finalColor = mix(orbColor.rgb, blendedAvatar, avatarMask);\\n            float finalAlpha = max(orbColor.a, avatarMask);\\n            \\n            return vec4(finalColor, finalAlpha);\\n        }\\n      }\\n\\n      return orbColor;\\n    }\\n\\n    vec4 mainImage(vec2 fragCoord) {\\n      vec2 center = iResolution.xy * 0.5;\\n      float size = min(iResolution.x, iResolution.y);\\n      vec2 uv = (fragCoord - center) / size * 2.0;\\n      \\n      float angle = rot;\\n      float s = sin(angle);\\n      float c = cos(angle);\\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\\n      \\n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\\n      \\n      return draw(uv);\\n    }\\n\\n    void main() {\\n      vec2 fragCoord = vUv * iResolution.xy;\\n      vec4 col = mainImage(fragCoord);\\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\\n    }\\n  \";\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Orb.useEffect\": ()=>{\n            const container = ctnDom.current;\n            if (!container) return;\n            const renderer = new ogl__WEBPACK_IMPORTED_MODULE_3__.Renderer({\n                alpha: true,\n                premultipliedAlpha: false\n            });\n            const gl = renderer.gl;\n            gl.clearColor(0, 0, 0, 0);\n            container.appendChild(gl.canvas);\n            const texture = new ogl__WEBPACK_IMPORTED_MODULE_4__.Texture(gl);\n            if (avatarUrl) {\n                const img = new Image();\n                img.crossOrigin = \"anonymous\";\n                img.src = avatarUrl;\n                img.onload = ({\n                    \"Orb.useEffect\": ()=>{\n                        texture.image = img;\n                    }\n                })[\"Orb.useEffect\"];\n            }\n            const geometry = new ogl__WEBPACK_IMPORTED_MODULE_5__.Triangle(gl);\n            const program = new ogl__WEBPACK_IMPORTED_MODULE_6__.Program(gl, {\n                vertex: vert,\n                fragment: frag,\n                uniforms: {\n                    iTime: {\n                        value: 0\n                    },\n                    iResolution: {\n                        value: new ogl__WEBPACK_IMPORTED_MODULE_7__.Vec3(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n                    },\n                    hue: {\n                        value: hue\n                    },\n                    hover: {\n                        value: 0\n                    },\n                    rot: {\n                        value: 0\n                    },\n                    hoverIntensity: {\n                        value: hoverIntensity\n                    },\n                    tMap: {\n                        value: texture\n                    },\n                    hasTexture: {\n                        value: avatarUrl ? 1.0 : 0.0\n                    }\n                }\n            });\n            const mesh = new ogl__WEBPACK_IMPORTED_MODULE_8__.Mesh(gl, {\n                geometry,\n                program\n            });\n            function resize() {\n                if (!container) return;\n                const dpr = window.devicePixelRatio || 1;\n                const width = container.clientWidth;\n                const height = container.clientHeight;\n                renderer.setSize(width * dpr, height * dpr);\n                gl.canvas.style.width = width + \"px\";\n                gl.canvas.style.height = height + \"px\";\n                program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height);\n            }\n            window.addEventListener(\"resize\", resize);\n            resize();\n            let targetHover = 0;\n            let lastTime = 0;\n            let currentRot = 0;\n            const rotationSpeed = 0.3;\n            const handleMouseMove = {\n                \"Orb.useEffect.handleMouseMove\": (e)=>{\n                    if (!container) return;\n                    const rect = container.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    const width = rect.width;\n                    const height = rect.height;\n                    const size = Math.min(width, height);\n                    const centerX = width / 2;\n                    const centerY = height / 2;\n                    const uvX = (x - centerX) / size * 2.0;\n                    const uvY = (y - centerY) / size * 2.0;\n                    if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n                        targetHover = 1;\n                    } else {\n                        targetHover = 0;\n                    }\n                }\n            }[\"Orb.useEffect.handleMouseMove\"];\n            const handleMouseLeave = {\n                \"Orb.useEffect.handleMouseLeave\": ()=>{\n                    targetHover = 0;\n                }\n            }[\"Orb.useEffect.handleMouseLeave\"];\n            container.addEventListener(\"mousemove\", handleMouseMove);\n            container.addEventListener(\"mouseleave\", handleMouseLeave);\n            let rafId;\n            const update = {\n                \"Orb.useEffect.update\": (t)=>{\n                    rafId = requestAnimationFrame(update);\n                    const dt = (t - lastTime) * 0.001;\n                    lastTime = t;\n                    program.uniforms.iTime.value = t * 0.001;\n                    program.uniforms.hue.value = hue;\n                    program.uniforms.hoverIntensity.value = hoverIntensity;\n                    const effectiveHover = forceHoverState ? 1 : targetHover;\n                    program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n                    if (rotateOnHover && effectiveHover > 0.5) {\n                        currentRot += dt * rotationSpeed;\n                    }\n                    program.uniforms.rot.value = currentRot;\n                    renderer.render({\n                        scene: mesh\n                    });\n                }\n            }[\"Orb.useEffect.update\"];\n            rafId = requestAnimationFrame(update);\n            return ({\n                \"Orb.useEffect\": ()=>{\n                    var _gl_getExtension;\n                    if (rafId) cancelAnimationFrame(rafId);\n                    window.removeEventListener(\"resize\", resize);\n                    if (container) {\n                        container.removeEventListener(\"mousemove\", handleMouseMove);\n                        container.removeEventListener(\"mouseleave\", handleMouseLeave);\n                        if (gl.canvas.parentNode === container) {\n                            container.removeChild(gl.canvas);\n                        }\n                    }\n                    (_gl_getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl_getExtension === void 0 ? void 0 : _gl_getExtension.loseContext();\n                }\n            })[\"Orb.useEffect\"];\n        }\n    }[\"Orb.useEffect\"], [\n        avatarUrl,\n        hue,\n        hoverIntensity,\n        rotateOnHover,\n        forceHoverState\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ctnDom,\n        className: \"orb-container\"\n    }, void 0, false, {\n        fileName: \"/Users/yangjunci/Documents/GitHub/fuyun-dev-website/components/Orb.tsx\",\n        lineNumber: 335,\n        columnNumber: 10\n    }, this);\n}\n_s(Orb, \"RK9NRNXyqwE64a4o6Ka2phRjmok=\");\n_c = Orb;\nvar _c;\n$RefreshReg$(_c, \"Orb\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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elV3QnpGO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMveWFuZ2p1bmNpL0RvY3VtZW50cy9HaXRIdWIvZnV5dW4tZGV2LXdlYnNpdGUvY29tcG9uZW50cy9PcmIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFJlbmRlcmVyLCBQcm9ncmFtLCBNZXNoLCBUcmlhbmdsZSwgVmVjMywgVGV4dHVyZSB9IGZyb20gXCJvZ2xcIjtcblxuaW1wb3J0IFwiLi9PcmIuY3NzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9yYih7XG4gIGh1ZSA9IDAsXG4gIGhvdmVySW50ZW5zaXR5ID0gMC4yLFxuICByb3RhdGVPbkhvdmVyID0gdHJ1ZSxcbiAgZm9yY2VIb3ZlclN0YXRlID0gZmFsc2UsXG4gIGF2YXRhclVybCxcbn06IHtcbiAgaHVlPzogbnVtYmVyO1xuICBob3ZlckludGVuc2l0eT86IG51bWJlcjtcbiAgcm90YXRlT25Ib3Zlcj86IGJvb2xlYW47XG4gIGZvcmNlSG92ZXJTdGF0ZT86IGJvb2xlYW47XG4gIGF2YXRhclVybD86IHN0cmluZztcbn0pIHtcbiAgY29uc3QgY3RuRG9tID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblxuICBjb25zdCB2ZXJ0ID0gLyogZ2xzbCAqLyBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICB9XG4gIGA7XG5cbiAgY29uc3QgZnJhZyA9IC8qIGdsc2wgKi8gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gZmxvYXQgaVRpbWU7XG4gICAgdW5pZm9ybSB2ZWMzIGlSZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgaHVlO1xuICAgIHVuaWZvcm0gZmxvYXQgaG92ZXI7XG4gICAgdW5pZm9ybSBmbG9hdCByb3Q7XG4gICAgdW5pZm9ybSBmbG9hdCBob3ZlckludGVuc2l0eTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB0TWFwO1xuICAgIHVuaWZvcm0gZmxvYXQgaGFzVGV4dHVyZTtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdmVjMyByZ2IyeWlxKHZlYzMgYykge1xuICAgICAgZmxvYXQgeSA9IGRvdChjLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcbiAgICAgIGZsb2F0IGkgPSBkb3QoYywgdmVjMygwLjU5NiwgLTAuMjc0LCAtMC4zMjIpKTtcbiAgICAgIGZsb2F0IHEgPSBkb3QoYywgdmVjMygwLjIxMSwgLTAuNTIzLCAwLjMxMikpO1xuICAgICAgcmV0dXJuIHZlYzMoeSwgaSwgcSk7XG4gICAgfVxuICAgIFxuICAgIHZlYzMgeWlxMnJnYih2ZWMzIGMpIHtcbiAgICAgIGZsb2F0IHIgPSBjLnggKyAwLjk1NiAqIGMueSArIDAuNjIxICogYy56O1xuICAgICAgZmxvYXQgZyA9IGMueCAtIDAuMjcyICogYy55IC0gMC42NDcgKiBjLno7XG4gICAgICBmbG9hdCBiID0gYy54IC0gMS4xMDYgKiBjLnkgKyAxLjcwMyAqIGMuejtcbiAgICAgIHJldHVybiB2ZWMzKHIsIGcsIGIpO1xuICAgIH1cbiAgICBcbiAgICB2ZWMzIGFkanVzdEh1ZSh2ZWMzIGNvbG9yLCBmbG9hdCBodWVEZWcpIHtcbiAgICAgIGZsb2F0IGh1ZVJhZCA9IGh1ZURlZyAqIDMuMTQxNTkyNjUgLyAxODAuMDtcbiAgICAgIHZlYzMgeWlxID0gcmdiMnlpcShjb2xvcik7XG4gICAgICBmbG9hdCBjb3NBID0gY29zKGh1ZVJhZCk7XG4gICAgICBmbG9hdCBzaW5BID0gc2luKGh1ZVJhZCk7XG4gICAgICBmbG9hdCBpID0geWlxLnkgKiBjb3NBIC0geWlxLnogKiBzaW5BO1xuICAgICAgZmxvYXQgcSA9IHlpcS55ICogc2luQSArIHlpcS56ICogY29zQTtcbiAgICAgIHlpcS55ID0gaTtcbiAgICAgIHlpcS56ID0gcTtcbiAgICAgIHJldHVybiB5aXEycmdiKHlpcSk7XG4gICAgfVxuXG4gICAgdmVjMyBoYXNoMzModmVjMyBwMykge1xuICAgICAgcDMgPSBmcmFjdChwMyAqIHZlYzMoMC4xMDMxLCAwLjExMzY5LCAwLjEzNzg3KSk7XG4gICAgICBwMyArPSBkb3QocDMsIHAzLnl4eiArIDE5LjE5KTtcbiAgICAgIHJldHVybiAtMS4wICsgMi4wICogZnJhY3QodmVjMyhcbiAgICAgICAgcDMueCArIHAzLnksXG4gICAgICAgIHAzLnggKyBwMy56LFxuICAgICAgICBwMy55ICsgcDMuelxuICAgICAgKSAqIHAzLnp5eCk7XG4gICAgfVxuXG4gICAgZmxvYXQgc25vaXNlMyh2ZWMzIHApIHtcbiAgICAgIGNvbnN0IGZsb2F0IEsxID0gMC4zMzMzMzMzMzM7XG4gICAgICBjb25zdCBmbG9hdCBLMiA9IDAuMTY2NjY2NjY3O1xuICAgICAgdmVjMyBpID0gZmxvb3IocCArIChwLnggKyBwLnkgKyBwLnopICogSzEpO1xuICAgICAgdmVjMyBkMCA9IHAgLSAoaSAtIChpLnggKyBpLnkgKyBpLnopICogSzIpO1xuICAgICAgdmVjMyBlID0gc3RlcCh2ZWMzKDAuMCksIGQwIC0gZDAueXp4KTtcbiAgICAgIHZlYzMgaTEgPSBlICogKDEuMCAtIGUuenh5KTtcbiAgICAgIHZlYzMgaTIgPSAxLjAgLSBlLnp4eSAqICgxLjAgLSBlKTtcbiAgICAgIHZlYzMgZDEgPSBkMCAtIChpMSAtIEsyKTtcbiAgICAgIHZlYzMgZDIgPSBkMCAtIChpMiAtIEsxKTtcbiAgICAgIHZlYzMgZDMgPSBkMCAtIDAuNTtcbiAgICAgIHZlYzQgaCA9IG1heCgwLjYgLSB2ZWM0KFxuICAgICAgICBkb3QoZDAsIGQwKSxcbiAgICAgICAgZG90KGQxLCBkMSksXG4gICAgICAgIGRvdChkMiwgZDIpLFxuICAgICAgICBkb3QoZDMsIGQzKVxuICAgICAgKSwgMC4wKTtcbiAgICAgIHZlYzQgbiA9IGggKiBoICogaCAqIGggKiB2ZWM0KFxuICAgICAgICBkb3QoZDAsIGhhc2gzMyhpKSksXG4gICAgICAgIGRvdChkMSwgaGFzaDMzKGkgKyBpMSkpLFxuICAgICAgICBkb3QoZDIsIGhhc2gzMyhpICsgaTIpKSxcbiAgICAgICAgZG90KGQzLCBoYXNoMzMoaSArIDEuMCkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvdCh2ZWM0KDMxLjMxNiksIG4pO1xuICAgIH1cblxuICAgIHZlYzQgZXh0cmFjdEFscGhhKHZlYzMgY29sb3JJbikge1xuICAgICAgZmxvYXQgYSA9IG1heChtYXgoY29sb3JJbi5yLCBjb2xvckluLmcpLCBjb2xvckluLmIpO1xuICAgICAgcmV0dXJuIHZlYzQoY29sb3JJbi5yZ2IgLyAoYSArIDFlLTUpLCBhKTtcbiAgICB9XG5cbiAgICBjb25zdCB2ZWMzIGJhc2VDb2xvcjEgPSB2ZWMzKDAuNjExNzY1LCAwLjI2Mjc0NSwgMC45OTYwNzgpO1xuICAgIGNvbnN0IHZlYzMgYmFzZUNvbG9yMiA9IHZlYzMoMC4yOTgwMzksIDAuNzYwNzg0LCAwLjkxMzcyNSk7XG4gICAgY29uc3QgdmVjMyBiYXNlQ29sb3IzID0gdmVjMygwLjA2Mjc0NSwgMC4wNzg0MzEsIDAuNjAwMDAwKTtcbiAgICBjb25zdCBmbG9hdCBpbm5lclJhZGl1cyA9IDAuNjtcbiAgICBjb25zdCBmbG9hdCBub2lzZVNjYWxlID0gMC42NTtcblxuICAgIGZsb2F0IGxpZ2h0MShmbG9hdCBpbnRlbnNpdHksIGZsb2F0IGF0dGVudWF0aW9uLCBmbG9hdCBkaXN0KSB7XG4gICAgICByZXR1cm4gaW50ZW5zaXR5IC8gKDEuMCArIGRpc3QgKiBhdHRlbnVhdGlvbik7XG4gICAgfVxuICAgIGZsb2F0IGxpZ2h0MihmbG9hdCBpbnRlbnNpdHksIGZsb2F0IGF0dGVudWF0aW9uLCBmbG9hdCBkaXN0KSB7XG4gICAgICByZXR1cm4gaW50ZW5zaXR5IC8gKDEuMCArIGRpc3QgKiBkaXN0ICogYXR0ZW51YXRpb24pO1xuICAgIH1cblxuICAgIHZlYzQgZHJhdyh2ZWMyIHV2KSB7XG4gICAgICB2ZWMzIGNvbG9yMSA9IGFkanVzdEh1ZShiYXNlQ29sb3IxLCBodWUpO1xuICAgICAgdmVjMyBjb2xvcjIgPSBhZGp1c3RIdWUoYmFzZUNvbG9yMiwgaHVlKTtcbiAgICAgIHZlYzMgY29sb3IzID0gYWRqdXN0SHVlKGJhc2VDb2xvcjMsIGh1ZSk7XG4gICAgICBcbiAgICAgIGZsb2F0IGFuZyA9IGF0YW4odXYueSwgdXYueCk7XG4gICAgICBmbG9hdCBsZW4gPSBsZW5ndGgodXYpO1xuICAgICAgZmxvYXQgaW52TGVuID0gbGVuID4gMC4wID8gMS4wIC8gbGVuIDogMC4wO1xuICAgICAgXG4gICAgICBmbG9hdCBuMCA9IHNub2lzZTModmVjMyh1diAqIG5vaXNlU2NhbGUsIGlUaW1lICogMC41KSkgKiAwLjUgKyAwLjU7XG4gICAgICBmbG9hdCByMCA9IG1peChtaXgoaW5uZXJSYWRpdXMsIDEuMCwgMC40KSwgbWl4KGlubmVyUmFkaXVzLCAxLjAsIDAuNiksIG4wKTtcbiAgICAgIGZsb2F0IGQwID0gZGlzdGFuY2UodXYsIChyMCAqIGludkxlbikgKiB1dik7XG4gICAgICBmbG9hdCB2MCA9IGxpZ2h0MSgxLjAsIDEwLjAsIGQwKTtcbiAgICAgIHYwICo9IHNtb290aHN0ZXAocjAgKiAxLjA1LCByMCwgbGVuKTtcbiAgICAgIGZsb2F0IGNsID0gY29zKGFuZyArIGlUaW1lICogMi4wKSAqIDAuNSArIDAuNTtcbiAgICAgIFxuICAgICAgZmxvYXQgYSA9IGlUaW1lICogLTEuMDtcbiAgICAgIHZlYzIgcG9zID0gdmVjMihjb3MoYSksIHNpbihhKSkgKiByMDtcbiAgICAgIGZsb2F0IGQgPSBkaXN0YW5jZSh1diwgcG9zKTtcbiAgICAgIGZsb2F0IHYxID0gbGlnaHQyKDEuNSwgNS4wLCBkKTtcbiAgICAgIHYxICo9IGxpZ2h0MSgxLjAsIDUwLjAsIGQwKTtcbiAgICAgIFxuICAgICAgZmxvYXQgdjIgPSBzbW9vdGhzdGVwKDEuMCwgbWl4KGlubmVyUmFkaXVzLCAxLjAsIG4wICogMC41KSwgbGVuKTtcbiAgICAgIGZsb2F0IHYzID0gc21vb3Roc3RlcChpbm5lclJhZGl1cywgbWl4KGlubmVyUmFkaXVzLCAxLjAsIDAuNSksIGxlbik7XG4gICAgICBcbiAgICAgIHZlYzMgY29sID0gbWl4KGNvbG9yMSwgY29sb3IyLCBjbCk7XG4gICAgICBjb2wgPSBtaXgoY29sb3IzLCBjb2wsIHYwKTtcbiAgICAgIGNvbCA9IChjb2wgKyB2MSkgKiB2MiAqIHYzO1xuICAgICAgY29sID0gY2xhbXAoY29sLCAwLjAsIDEuMCk7XG4gICAgICBcbiAgICAgIHZlYzQgb3JiQ29sb3IgPSBleHRyYWN0QWxwaGEoY29sKTtcblxuICAgICAgaWYgKGhhc1RleHR1cmUgPiAwLjUpIHtcbiAgICAgICAgZmxvYXQgYXZhdGFyUmFkaXVzID0gMC41O1xuICAgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHV2KTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBzbW9vdGggY2lyY3VsYXIgbWFzayBmb3IgdGhlIGF2YXRhclxuICAgICAgICBmbG9hdCBhdmF0YXJNYXNrID0gMS4wIC0gc21vb3Roc3RlcChhdmF0YXJSYWRpdXMsIGF2YXRhclJhZGl1cyArIDAuMDUsIGRpc3QpO1xuXG4gICAgICAgIGlmIChhdmF0YXJNYXNrID4gMC4wKSB7XG4gICAgICAgICAgICAvLyBNYXAgVVZzIHRvIHNhbXBsZSB0aGUgdGV4dHVyZSBjb3JyZWN0bHkgd2l0aGluIHRoZSBjaXJjbGVcbiAgICAgICAgICAgIHZlYzIgYXZhdGFyVVYgPSB1diAvIGF2YXRhclJhZGl1cyAqIDAuNSArIDAuNTtcbiAgICAgICAgICAgIHZlYzQgYXZhdGFyVGV4Q29sb3IgPSB0ZXh0dXJlMkQodE1hcCwgYXZhdGFyVVYpO1xuXG4gICAgICAgICAgICAvLyBCbGVuZCBhdmF0YXIgd2l0aCB0aGUgb3JiJ3MgY29sb3IgZm9yIGEgJ2Z1c2VkJyBsb29rXG4gICAgICAgICAgICB2ZWMzIGJsZW5kZWRBdmF0YXIgPSBtaXgoYXZhdGFyVGV4Q29sb3IucmdiLCBvcmJDb2xvci5yZ2IsIDAuNCk7XG5cbiAgICAgICAgICAgIC8vIE5vdyBwbGFjZSB0aGUgYmxlbmRlZCBhdmF0YXIgaW50byB0aGUgbWFpbiBvcmIgdXNpbmcgdGhlIG1hc2tcbiAgICAgICAgICAgIHZlYzMgZmluYWxDb2xvciA9IG1peChvcmJDb2xvci5yZ2IsIGJsZW5kZWRBdmF0YXIsIGF2YXRhck1hc2spO1xuICAgICAgICAgICAgZmxvYXQgZmluYWxBbHBoYSA9IG1heChvcmJDb2xvci5hLCBhdmF0YXJNYXNrKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQoZmluYWxDb2xvciwgZmluYWxBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yYkNvbG9yO1xuICAgIH1cblxuICAgIHZlYzQgbWFpbkltYWdlKHZlYzIgZnJhZ0Nvb3JkKSB7XG4gICAgICB2ZWMyIGNlbnRlciA9IGlSZXNvbHV0aW9uLnh5ICogMC41O1xuICAgICAgZmxvYXQgc2l6ZSA9IG1pbihpUmVzb2x1dGlvbi54LCBpUmVzb2x1dGlvbi55KTtcbiAgICAgIHZlYzIgdXYgPSAoZnJhZ0Nvb3JkIC0gY2VudGVyKSAvIHNpemUgKiAyLjA7XG4gICAgICBcbiAgICAgIGZsb2F0IGFuZ2xlID0gcm90O1xuICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZSk7XG4gICAgICBmbG9hdCBjID0gY29zKGFuZ2xlKTtcbiAgICAgIHV2ID0gdmVjMihjICogdXYueCAtIHMgKiB1di55LCBzICogdXYueCArIGMgKiB1di55KTtcbiAgICAgIFxuICAgICAgdXYueCArPSBob3ZlciAqIGhvdmVySW50ZW5zaXR5ICogMC4xICogc2luKHV2LnkgKiAxMC4wICsgaVRpbWUpO1xuICAgICAgdXYueSArPSBob3ZlciAqIGhvdmVySW50ZW5zaXR5ICogMC4xICogc2luKHV2LnggKiAxMC4wICsgaVRpbWUpO1xuICAgICAgXG4gICAgICByZXR1cm4gZHJhdyh1dik7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiBmcmFnQ29vcmQgPSB2VXYgKiBpUmVzb2x1dGlvbi54eTtcbiAgICAgIHZlYzQgY29sID0gbWFpbkltYWdlKGZyYWdDb29yZCk7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbC5yZ2IgKiBjb2wuYSwgY29sLmEpO1xuICAgIH1cbiAgYDtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGN0bkRvbS5jdXJyZW50O1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7IGFscGhhOiB0cnVlLCBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2wuY2FudmFzKTtcblxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCk7XG4gICAgaWYgKGF2YXRhclVybCkge1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgaW1nLnNyYyA9IGF2YXRhclVybDtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRyaWFuZ2xlKGdsKTtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHtcbiAgICAgIHZlcnRleDogdmVydCxcbiAgICAgIGZyYWdtZW50OiBmcmFnLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaVRpbWU6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgaVJlc29sdXRpb246IHtcbiAgICAgICAgICB2YWx1ZTogbmV3IFZlYzMoXG4gICAgICAgICAgICBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICBnbC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgZ2wuY2FudmFzLndpZHRoIC8gZ2wuY2FudmFzLmhlaWdodFxuICAgICAgICAgICksXG4gICAgICAgIH0sXG4gICAgICAgIGh1ZTogeyB2YWx1ZTogaHVlIH0sXG4gICAgICAgIGhvdmVyOiB7IHZhbHVlOiAwIH0sXG4gICAgICAgIHJvdDogeyB2YWx1ZTogMCB9LFxuICAgICAgICBob3ZlckludGVuc2l0eTogeyB2YWx1ZTogaG92ZXJJbnRlbnNpdHkgfSxcbiAgICAgICAgdE1hcDogeyB2YWx1ZTogdGV4dHVyZSB9LFxuICAgICAgICBoYXNUZXh0dXJlOiB7IHZhbHVlOiBhdmF0YXJVcmwgPyAxLjAgOiAwLjAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2wsIHsgZ2VvbWV0cnksIHByb2dyYW0gfSk7XG5cbiAgICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgICAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICBnbC5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgIGdsLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLmlSZXNvbHV0aW9uLnZhbHVlLnNldChcbiAgICAgICAgZ2wuY2FudmFzLndpZHRoLFxuICAgICAgICBnbC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICBnbC5jYW52YXMud2lkdGggLyBnbC5jYW52YXMuaGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemUpO1xuICAgIHJlc2l6ZSgpO1xuXG4gICAgbGV0IHRhcmdldEhvdmVyID0gMDtcbiAgICBsZXQgbGFzdFRpbWUgPSAwO1xuICAgIGxldCBjdXJyZW50Um90ID0gMDtcbiAgICBjb25zdCByb3RhdGlvblNwZWVkID0gMC4zO1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIGNvbnN0IHkgPSBlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgY2VudGVyWCA9IHdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBoZWlnaHQgLyAyO1xuICAgICAgY29uc3QgdXZYID0gKCh4IC0gY2VudGVyWCkgLyBzaXplKSAqIDIuMDtcbiAgICAgIGNvbnN0IHV2WSA9ICgoeSAtIGNlbnRlclkpIC8gc2l6ZSkgKiAyLjA7XG5cbiAgICAgIGlmIChNYXRoLnNxcnQodXZYICogdXZYICsgdXZZICogdXZZKSA8IDAuOCkge1xuICAgICAgICB0YXJnZXRIb3ZlciA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRIb3ZlciA9IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgICB0YXJnZXRIb3ZlciA9IDA7XG4gICAgfTtcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGhhbmRsZU1vdXNlTGVhdmUpO1xuXG4gICAgbGV0IHJhZklkOiBudW1iZXI7XG4gICAgY29uc3QgdXBkYXRlID0gKHQ6IG51bWJlcikgPT4ge1xuICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcbiAgICAgIGNvbnN0IGR0ID0gKHQgLSBsYXN0VGltZSkgKiAwLjAwMTtcbiAgICAgIGxhc3RUaW1lID0gdDtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaVRpbWUudmFsdWUgPSB0ICogMC4wMDE7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLmh1ZS52YWx1ZSA9IGh1ZTtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaG92ZXJJbnRlbnNpdHkudmFsdWUgPSBob3ZlckludGVuc2l0eTtcblxuICAgICAgY29uc3QgZWZmZWN0aXZlSG92ZXIgPSBmb3JjZUhvdmVyU3RhdGUgPyAxIDogdGFyZ2V0SG92ZXI7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLmhvdmVyLnZhbHVlICs9XG4gICAgICAgIChlZmZlY3RpdmVIb3ZlciAtIHByb2dyYW0udW5pZm9ybXMuaG92ZXIudmFsdWUpICogMC4xO1xuXG4gICAgICBpZiAocm90YXRlT25Ib3ZlciAmJiBlZmZlY3RpdmVIb3ZlciA+IDAuNSkge1xuICAgICAgICBjdXJyZW50Um90ICs9IGR0ICogcm90YXRpb25TcGVlZDtcbiAgICAgIH1cbiAgICAgIHByb2dyYW0udW5pZm9ybXMucm90LnZhbHVlID0gY3VycmVudFJvdDtcblxuICAgICAgcmVuZGVyZXIucmVuZGVyKHsgc2NlbmU6IG1lc2ggfSk7XG4gICAgfTtcbiAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyYWZJZCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplKTtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGhhbmRsZU1vdXNlTGVhdmUpO1xuICAgICAgICBpZiAoZ2wuY2FudmFzLnBhcmVudE5vZGUgPT09IGNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChnbC5jYW52YXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIik/Lmxvc2VDb250ZXh0KCk7XG4gICAgfTtcbiAgfSwgW2F2YXRhclVybCwgaHVlLCBob3ZlckludGVuc2l0eSwgcm90YXRlT25Ib3ZlciwgZm9yY2VIb3ZlclN0YXRlXSk7XG5cbiAgcmV0dXJuIDxkaXYgcmVmPXtjdG5Eb219IGNsYXNzTmFtZT1cIm9yYi1jb250YWluZXJcIiAvPjtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJSZW5kZXJlciIsIlByb2dyYW0iLCJNZXNoIiwiVHJpYW5nbGUiLCJWZWMzIiwiVGV4dHVyZSIsIk9yYiIsImh1ZSIsImhvdmVySW50ZW5zaXR5Iiwicm90YXRlT25Ib3ZlciIsImZvcmNlSG92ZXJTdGF0ZSIsImF2YXRhclVybCIsImN0bkRvbSIsInZlcnQiLCJmcmFnIiwiY29udGFpbmVyIiwiY3VycmVudCIsInJlbmRlcmVyIiwiYWxwaGEiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJnbCIsImNsZWFyQ29sb3IiLCJhcHBlbmRDaGlsZCIsImNhbnZhcyIsInRleHR1cmUiLCJpbWciLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3JjIiwib25sb2FkIiwiaW1hZ2UiLCJnZW9tZXRyeSIsInByb2dyYW0iLCJ2ZXJ0ZXgiLCJmcmFnbWVudCIsInVuaWZvcm1zIiwiaVRpbWUiLCJ2YWx1ZSIsImlSZXNvbHV0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJob3ZlciIsInJvdCIsInRNYXAiLCJoYXNUZXh0dXJlIiwibWVzaCIsInJlc2l6ZSIsImRwciIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInNldFNpemUiLCJzdHlsZSIsInNldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0YXJnZXRIb3ZlciIsImxhc3RUaW1lIiwiY3VycmVudFJvdCIsInJvdGF0aW9uU3BlZWQiLCJoYW5kbGVNb3VzZU1vdmUiLCJlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJjbGllbnRYIiwibGVmdCIsInkiLCJjbGllbnRZIiwidG9wIiwic2l6ZSIsIk1hdGgiLCJtaW4iLCJjZW50ZXJYIiwiY2VudGVyWSIsInV2WCIsInV2WSIsInNxcnQiLCJoYW5kbGVNb3VzZUxlYXZlIiwicmFmSWQiLCJ1cGRhdGUiLCJ0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZHQiLCJlZmZlY3RpdmVIb3ZlciIsInJlbmRlciIsInNjZW5lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZ2V0RXh0ZW5zaW9uIiwibG9zZUNvbnRleHQiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Orb.tsx\n"));

/***/ })

});