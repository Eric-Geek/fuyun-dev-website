"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Orb.tsx":
/*!****************************!*\
  !*** ./components/Orb.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Orb)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Texture.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/math/Vec3.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Mesh.js\");\n/* harmony import */ var _Orb_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Orb.css */ \"(app-pages-browser)/./components/Orb.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction Orb(param) {\n    let { hue = 0, hoverIntensity = 0.2, rotateOnHover = true, forceHoverState = false, avatarUrl } = param;\n    _s();\n    const ctnDom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const vert = \"\\n    precision highp float;\\n    attribute vec2 position;\\n    attribute vec2 uv;\\n    varying vec2 vUv;\\n    void main() {\\n      vUv = uv;\\n      gl_Position = vec4(position, 0.0, 1.0);\\n    }\\n  \";\n    const frag = \"\\n    precision highp float;\\n\\n    uniform float iTime;\\n    uniform vec3 iResolution;\\n    uniform float hue;\\n    uniform float hover;\\n    uniform float rot;\\n    uniform float hoverIntensity;\\n    uniform sampler2D tMap;\\n    uniform float hasTexture;\\n    varying vec2 vUv;\\n\\n    vec3 rgb2yiq(vec3 c) {\\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\\n      return vec3(y, i, q);\\n    }\\n    \\n    vec3 yiq2rgb(vec3 c) {\\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\\n      return vec3(r, g, b);\\n    }\\n    \\n    vec3 adjustHue(vec3 color, float hueDeg) {\\n      float hueRad = hueDeg * 3.14159265 / 180.0;\\n      vec3 yiq = rgb2yiq(color);\\n      float cosA = cos(hueRad);\\n      float sinA = sin(hueRad);\\n      float i = yiq.y * cosA - yiq.z * sinA;\\n      float q = yiq.y * sinA + yiq.z * cosA;\\n      yiq.y = i;\\n      yiq.z = q;\\n      return yiq2rgb(yiq);\\n    }\\n\\n    vec3 hash33(vec3 p3) {\\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\\n      p3 += dot(p3, p3.yxz + 19.19);\\n      return -1.0 + 2.0 * fract(vec3(\\n        p3.x + p3.y,\\n        p3.x + p3.z,\\n        p3.y + p3.z\\n      ) * p3.zyx);\\n    }\\n\\n    float snoise3(vec3 p) {\\n      const float K1 = 0.333333333;\\n      const float K2 = 0.166666667;\\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n      vec3 i1 = e * (1.0 - e.zxy);\\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n      vec3 d1 = d0 - (i1 - K2);\\n      vec3 d2 = d0 - (i2 - K1);\\n      vec3 d3 = d0 - 0.5;\\n      vec4 h = max(0.6 - vec4(\\n        dot(d0, d0),\\n        dot(d1, d1),\\n        dot(d2, d2),\\n        dot(d3, d3)\\n      ), 0.0);\\n      vec4 n = h * h * h * h * vec4(\\n        dot(d0, hash33(i)),\\n        dot(d1, hash33(i + i1)),\\n        dot(d2, hash33(i + i2)),\\n        dot(d3, hash33(i + 1.0))\\n      );\\n      return dot(vec4(31.316), n);\\n    }\\n\\n    vec4 extractAlpha(vec3 colorIn) {\\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\\n      return vec4(colorIn.rgb / (a + 1e-5), a);\\n    }\\n\\n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\\n    const float innerRadius = 0.6;\\n    const float noiseScale = 0.65;\\n\\n    float light1(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * attenuation);\\n    }\\n    float light2(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * dist * attenuation);\\n    }\\n\\n    vec4 draw(vec2 uv) {\\n      vec3 color1 = adjustHue(baseColor1, hue);\\n      vec3 color2 = adjustHue(baseColor2, hue);\\n      vec3 color3 = adjustHue(baseColor3, hue);\\n      \\n      float ang = atan(uv.y, uv.x);\\n      float len = length(uv);\\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\\n      \\n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\\n      float d0 = distance(uv, (r0 * invLen) * uv);\\n      float v0 = light1(1.0, 10.0, d0);\\n      v0 *= smoothstep(r0 * 1.05, r0, len);\\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\\n      \\n      float a = iTime * -1.0;\\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\\n      float d = distance(uv, pos);\\n      float v1 = light2(1.5, 5.0, d);\\n      v1 *= light1(1.0, 50.0, d0);\\n      \\n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\\n      \\n      vec3 col = mix(color1, color2, cl);\\n      col = mix(color3, col, v0);\\n      col = (col + v1) * v2 * v3;\\n      col = clamp(col, 0.0, 1.0);\\n      \\n      vec4 orbColor = extractAlpha(col);\\n\\n      if (hasTexture > 0.5) {\\n        vec2 texUv = uv * 0.5 + 0.5;\\n        vec4 avatarColor = texture2D(tMap, texUv);\\n        \\n        // Blend the avatar with the orb effect\\n        vec3 finalColor = mix(avatarColor.rgb, orbColor.rgb, orbColor.a * 0.7); \\n        float finalAlpha = orbColor.a;\\n\\n        return vec4(finalColor, finalAlpha);\\n      } else {\\n        return orbColor;\\n      }\\n    }\\n\\n    vec4 mainImage(vec2 fragCoord) {\\n      vec2 center = iResolution.xy * 0.5;\\n      float size = min(iResolution.x, iResolution.y);\\n      vec2 uv = (fragCoord - center) / size * 2.0;\\n      \\n      float angle = rot;\\n      float s = sin(angle);\\n      float c = cos(angle);\\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\\n      \\n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\\n      \\n      return draw(uv);\\n    }\\n\\n    void main() {\\n      vec2 fragCoord = vUv * iResolution.xy;\\n      vec4 col = mainImage(fragCoord);\\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\\n    }\\n  \";\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Orb.useEffect\": ()=>{\n            const container = ctnDom.current;\n            if (!container) return;\n            const renderer = new ogl__WEBPACK_IMPORTED_MODULE_3__.Renderer({\n                alpha: true,\n                premultipliedAlpha: false\n            });\n            const gl = renderer.gl;\n            gl.clearColor(0, 0, 0, 0);\n            container.appendChild(gl.canvas);\n            const texture = new ogl__WEBPACK_IMPORTED_MODULE_4__.Texture(gl);\n            if (avatarUrl) {\n                const img = new Image();\n                img.crossOrigin = \"anonymous\";\n                img.src = avatarUrl;\n                img.onload = ({\n                    \"Orb.useEffect\": ()=>{\n                        texture.image = img;\n                    }\n                })[\"Orb.useEffect\"];\n            }\n            const geometry = new ogl__WEBPACK_IMPORTED_MODULE_5__.Triangle(gl);\n            const program = new ogl__WEBPACK_IMPORTED_MODULE_6__.Program(gl, {\n                vertex: vert,\n                fragment: frag,\n                uniforms: {\n                    iTime: {\n                        value: 0\n                    },\n                    iResolution: {\n                        value: new ogl__WEBPACK_IMPORTED_MODULE_7__.Vec3(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n                    },\n                    hue: {\n                        value: hue\n                    },\n                    hover: {\n                        value: 0\n                    },\n                    rot: {\n                        value: 0\n                    },\n                    hoverIntensity: {\n                        value: hoverIntensity\n                    },\n                    tMap: {\n                        value: texture\n                    },\n                    hasTexture: {\n                        value: avatarUrl ? 1.0 : 0.0\n                    }\n                }\n            });\n            const mesh = new ogl__WEBPACK_IMPORTED_MODULE_8__.Mesh(gl, {\n                geometry,\n                program\n            });\n            function resize() {\n                if (!container) return;\n                const dpr = window.devicePixelRatio || 1;\n                const width = container.clientWidth;\n                const height = container.clientHeight;\n                renderer.setSize(width * dpr, height * dpr);\n                gl.canvas.style.width = width + \"px\";\n                gl.canvas.style.height = height + \"px\";\n                program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height);\n            }\n            window.addEventListener(\"resize\", resize);\n            resize();\n            let targetHover = 0;\n            let lastTime = 0;\n            let currentRot = 0;\n            const rotationSpeed = 0.3;\n            const handleMouseMove = {\n                \"Orb.useEffect.handleMouseMove\": (e)=>{\n                    if (!container) return;\n                    const rect = container.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    const width = rect.width;\n                    const height = rect.height;\n                    const size = Math.min(width, height);\n                    const centerX = width / 2;\n                    const centerY = height / 2;\n                    const uvX = (x - centerX) / size * 2.0;\n                    const uvY = (y - centerY) / size * 2.0;\n                    if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n                        targetHover = 1;\n                    } else {\n                        targetHover = 0;\n                    }\n                }\n            }[\"Orb.useEffect.handleMouseMove\"];\n            const handleMouseLeave = {\n                \"Orb.useEffect.handleMouseLeave\": ()=>{\n                    targetHover = 0;\n                }\n            }[\"Orb.useEffect.handleMouseLeave\"];\n            container.addEventListener(\"mousemove\", handleMouseMove);\n            container.addEventListener(\"mouseleave\", handleMouseLeave);\n            let rafId;\n            const update = {\n                \"Orb.useEffect.update\": (t)=>{\n                    rafId = requestAnimationFrame(update);\n                    const dt = (t - lastTime) * 0.001;\n                    lastTime = t;\n                    program.uniforms.iTime.value = t * 0.001;\n                    program.uniforms.hue.value = hue;\n                    program.uniforms.hoverIntensity.value = hoverIntensity;\n                    const effectiveHover = forceHoverState ? 1 : targetHover;\n                    program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n                    if (rotateOnHover && effectiveHover > 0.5) {\n                        currentRot += dt * rotationSpeed;\n                    }\n                    program.uniforms.rot.value = currentRot;\n                    renderer.render({\n                        scene: mesh\n                    });\n                }\n            }[\"Orb.useEffect.update\"];\n            rafId = requestAnimationFrame(update);\n            return ({\n                \"Orb.useEffect\": ()=>{\n                    var _gl_getExtension;\n                    if (rafId) cancelAnimationFrame(rafId);\n                    window.removeEventListener(\"resize\", resize);\n                    if (container) {\n                        container.removeEventListener(\"mousemove\", handleMouseMove);\n                        container.removeEventListener(\"mouseleave\", handleMouseLeave);\n                        if (gl.canvas.parentNode === container) {\n                            container.removeChild(gl.canvas);\n                        }\n                    }\n                    (_gl_getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl_getExtension === void 0 ? void 0 : _gl_getExtension.loseContext();\n                }\n            })[\"Orb.useEffect\"];\n        }\n    }[\"Orb.useEffect\"], [\n        avatarUrl,\n        hue,\n        hoverIntensity,\n        rotateOnHover,\n        forceHoverState\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ctnDom,\n        className: \"orb-container\"\n    }, void 0, false, {\n        fileName: \"/Users/yangjunci/Documents/GitHub/fuyun-dev-website/components/Orb.tsx\",\n        lineNumber: 323,\n        columnNumber: 10\n    }, this);\n}\n_s(Orb, \"RK9NRNXyqwE64a4o6Ka2phRjmok=\");\n_c = Orb;\nvar _c;\n$RefreshReg$(_c, \"Orb\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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N1R3QnpGO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMveWFuZ2p1bmNpL0RvY3VtZW50cy9HaXRIdWIvZnV5dW4tZGV2LXdlYnNpdGUvY29tcG9uZW50cy9PcmIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFJlbmRlcmVyLCBQcm9ncmFtLCBNZXNoLCBUcmlhbmdsZSwgVmVjMywgVGV4dHVyZSB9IGZyb20gXCJvZ2xcIjtcblxuaW1wb3J0IFwiLi9PcmIuY3NzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9yYih7XG4gIGh1ZSA9IDAsXG4gIGhvdmVySW50ZW5zaXR5ID0gMC4yLFxuICByb3RhdGVPbkhvdmVyID0gdHJ1ZSxcbiAgZm9yY2VIb3ZlclN0YXRlID0gZmFsc2UsXG4gIGF2YXRhclVybCxcbn06IHtcbiAgaHVlPzogbnVtYmVyO1xuICBob3ZlckludGVuc2l0eT86IG51bWJlcjtcbiAgcm90YXRlT25Ib3Zlcj86IGJvb2xlYW47XG4gIGZvcmNlSG92ZXJTdGF0ZT86IGJvb2xlYW47XG4gIGF2YXRhclVybD86IHN0cmluZztcbn0pIHtcbiAgY29uc3QgY3RuRG9tID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblxuICBjb25zdCB2ZXJ0ID0gLyogZ2xzbCAqLyBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdlV2ID0gdXY7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICB9XG4gIGA7XG5cbiAgY29uc3QgZnJhZyA9IC8qIGdsc2wgKi8gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gZmxvYXQgaVRpbWU7XG4gICAgdW5pZm9ybSB2ZWMzIGlSZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgaHVlO1xuICAgIHVuaWZvcm0gZmxvYXQgaG92ZXI7XG4gICAgdW5pZm9ybSBmbG9hdCByb3Q7XG4gICAgdW5pZm9ybSBmbG9hdCBob3ZlckludGVuc2l0eTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB0TWFwO1xuICAgIHVuaWZvcm0gZmxvYXQgaGFzVGV4dHVyZTtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdmVjMyByZ2IyeWlxKHZlYzMgYykge1xuICAgICAgZmxvYXQgeSA9IGRvdChjLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcbiAgICAgIGZsb2F0IGkgPSBkb3QoYywgdmVjMygwLjU5NiwgLTAuMjc0LCAtMC4zMjIpKTtcbiAgICAgIGZsb2F0IHEgPSBkb3QoYywgdmVjMygwLjIxMSwgLTAuNTIzLCAwLjMxMikpO1xuICAgICAgcmV0dXJuIHZlYzMoeSwgaSwgcSk7XG4gICAgfVxuICAgIFxuICAgIHZlYzMgeWlxMnJnYih2ZWMzIGMpIHtcbiAgICAgIGZsb2F0IHIgPSBjLnggKyAwLjk1NiAqIGMueSArIDAuNjIxICogYy56O1xuICAgICAgZmxvYXQgZyA9IGMueCAtIDAuMjcyICogYy55IC0gMC42NDcgKiBjLno7XG4gICAgICBmbG9hdCBiID0gYy54IC0gMS4xMDYgKiBjLnkgKyAxLjcwMyAqIGMuejtcbiAgICAgIHJldHVybiB2ZWMzKHIsIGcsIGIpO1xuICAgIH1cbiAgICBcbiAgICB2ZWMzIGFkanVzdEh1ZSh2ZWMzIGNvbG9yLCBmbG9hdCBodWVEZWcpIHtcbiAgICAgIGZsb2F0IGh1ZVJhZCA9IGh1ZURlZyAqIDMuMTQxNTkyNjUgLyAxODAuMDtcbiAgICAgIHZlYzMgeWlxID0gcmdiMnlpcShjb2xvcik7XG4gICAgICBmbG9hdCBjb3NBID0gY29zKGh1ZVJhZCk7XG4gICAgICBmbG9hdCBzaW5BID0gc2luKGh1ZVJhZCk7XG4gICAgICBmbG9hdCBpID0geWlxLnkgKiBjb3NBIC0geWlxLnogKiBzaW5BO1xuICAgICAgZmxvYXQgcSA9IHlpcS55ICogc2luQSArIHlpcS56ICogY29zQTtcbiAgICAgIHlpcS55ID0gaTtcbiAgICAgIHlpcS56ID0gcTtcbiAgICAgIHJldHVybiB5aXEycmdiKHlpcSk7XG4gICAgfVxuXG4gICAgdmVjMyBoYXNoMzModmVjMyBwMykge1xuICAgICAgcDMgPSBmcmFjdChwMyAqIHZlYzMoMC4xMDMxLCAwLjExMzY5LCAwLjEzNzg3KSk7XG4gICAgICBwMyArPSBkb3QocDMsIHAzLnl4eiArIDE5LjE5KTtcbiAgICAgIHJldHVybiAtMS4wICsgMi4wICogZnJhY3QodmVjMyhcbiAgICAgICAgcDMueCArIHAzLnksXG4gICAgICAgIHAzLnggKyBwMy56LFxuICAgICAgICBwMy55ICsgcDMuelxuICAgICAgKSAqIHAzLnp5eCk7XG4gICAgfVxuXG4gICAgZmxvYXQgc25vaXNlMyh2ZWMzIHApIHtcbiAgICAgIGNvbnN0IGZsb2F0IEsxID0gMC4zMzMzMzMzMzM7XG4gICAgICBjb25zdCBmbG9hdCBLMiA9IDAuMTY2NjY2NjY3O1xuICAgICAgdmVjMyBpID0gZmxvb3IocCArIChwLnggKyBwLnkgKyBwLnopICogSzEpO1xuICAgICAgdmVjMyBkMCA9IHAgLSAoaSAtIChpLnggKyBpLnkgKyBpLnopICogSzIpO1xuICAgICAgdmVjMyBlID0gc3RlcCh2ZWMzKDAuMCksIGQwIC0gZDAueXp4KTtcbiAgICAgIHZlYzMgaTEgPSBlICogKDEuMCAtIGUuenh5KTtcbiAgICAgIHZlYzMgaTIgPSAxLjAgLSBlLnp4eSAqICgxLjAgLSBlKTtcbiAgICAgIHZlYzMgZDEgPSBkMCAtIChpMSAtIEsyKTtcbiAgICAgIHZlYzMgZDIgPSBkMCAtIChpMiAtIEsxKTtcbiAgICAgIHZlYzMgZDMgPSBkMCAtIDAuNTtcbiAgICAgIHZlYzQgaCA9IG1heCgwLjYgLSB2ZWM0KFxuICAgICAgICBkb3QoZDAsIGQwKSxcbiAgICAgICAgZG90KGQxLCBkMSksXG4gICAgICAgIGRvdChkMiwgZDIpLFxuICAgICAgICBkb3QoZDMsIGQzKVxuICAgICAgKSwgMC4wKTtcbiAgICAgIHZlYzQgbiA9IGggKiBoICogaCAqIGggKiB2ZWM0KFxuICAgICAgICBkb3QoZDAsIGhhc2gzMyhpKSksXG4gICAgICAgIGRvdChkMSwgaGFzaDMzKGkgKyBpMSkpLFxuICAgICAgICBkb3QoZDIsIGhhc2gzMyhpICsgaTIpKSxcbiAgICAgICAgZG90KGQzLCBoYXNoMzMoaSArIDEuMCkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvdCh2ZWM0KDMxLjMxNiksIG4pO1xuICAgIH1cblxuICAgIHZlYzQgZXh0cmFjdEFscGhhKHZlYzMgY29sb3JJbikge1xuICAgICAgZmxvYXQgYSA9IG1heChtYXgoY29sb3JJbi5yLCBjb2xvckluLmcpLCBjb2xvckluLmIpO1xuICAgICAgcmV0dXJuIHZlYzQoY29sb3JJbi5yZ2IgLyAoYSArIDFlLTUpLCBhKTtcbiAgICB9XG5cbiAgICBjb25zdCB2ZWMzIGJhc2VDb2xvcjEgPSB2ZWMzKDAuNjExNzY1LCAwLjI2Mjc0NSwgMC45OTYwNzgpO1xuICAgIGNvbnN0IHZlYzMgYmFzZUNvbG9yMiA9IHZlYzMoMC4yOTgwMzksIDAuNzYwNzg0LCAwLjkxMzcyNSk7XG4gICAgY29uc3QgdmVjMyBiYXNlQ29sb3IzID0gdmVjMygwLjA2Mjc0NSwgMC4wNzg0MzEsIDAuNjAwMDAwKTtcbiAgICBjb25zdCBmbG9hdCBpbm5lclJhZGl1cyA9IDAuNjtcbiAgICBjb25zdCBmbG9hdCBub2lzZVNjYWxlID0gMC42NTtcblxuICAgIGZsb2F0IGxpZ2h0MShmbG9hdCBpbnRlbnNpdHksIGZsb2F0IGF0dGVudWF0aW9uLCBmbG9hdCBkaXN0KSB7XG4gICAgICByZXR1cm4gaW50ZW5zaXR5IC8gKDEuMCArIGRpc3QgKiBhdHRlbnVhdGlvbik7XG4gICAgfVxuICAgIGZsb2F0IGxpZ2h0MihmbG9hdCBpbnRlbnNpdHksIGZsb2F0IGF0dGVudWF0aW9uLCBmbG9hdCBkaXN0KSB7XG4gICAgICByZXR1cm4gaW50ZW5zaXR5IC8gKDEuMCArIGRpc3QgKiBkaXN0ICogYXR0ZW51YXRpb24pO1xuICAgIH1cblxuICAgIHZlYzQgZHJhdyh2ZWMyIHV2KSB7XG4gICAgICB2ZWMzIGNvbG9yMSA9IGFkanVzdEh1ZShiYXNlQ29sb3IxLCBodWUpO1xuICAgICAgdmVjMyBjb2xvcjIgPSBhZGp1c3RIdWUoYmFzZUNvbG9yMiwgaHVlKTtcbiAgICAgIHZlYzMgY29sb3IzID0gYWRqdXN0SHVlKGJhc2VDb2xvcjMsIGh1ZSk7XG4gICAgICBcbiAgICAgIGZsb2F0IGFuZyA9IGF0YW4odXYueSwgdXYueCk7XG4gICAgICBmbG9hdCBsZW4gPSBsZW5ndGgodXYpO1xuICAgICAgZmxvYXQgaW52TGVuID0gbGVuID4gMC4wID8gMS4wIC8gbGVuIDogMC4wO1xuICAgICAgXG4gICAgICBmbG9hdCBuMCA9IHNub2lzZTModmVjMyh1diAqIG5vaXNlU2NhbGUsIGlUaW1lICogMC41KSkgKiAwLjUgKyAwLjU7XG4gICAgICBmbG9hdCByMCA9IG1peChtaXgoaW5uZXJSYWRpdXMsIDEuMCwgMC40KSwgbWl4KGlubmVyUmFkaXVzLCAxLjAsIDAuNiksIG4wKTtcbiAgICAgIGZsb2F0IGQwID0gZGlzdGFuY2UodXYsIChyMCAqIGludkxlbikgKiB1dik7XG4gICAgICBmbG9hdCB2MCA9IGxpZ2h0MSgxLjAsIDEwLjAsIGQwKTtcbiAgICAgIHYwICo9IHNtb290aHN0ZXAocjAgKiAxLjA1LCByMCwgbGVuKTtcbiAgICAgIGZsb2F0IGNsID0gY29zKGFuZyArIGlUaW1lICogMi4wKSAqIDAuNSArIDAuNTtcbiAgICAgIFxuICAgICAgZmxvYXQgYSA9IGlUaW1lICogLTEuMDtcbiAgICAgIHZlYzIgcG9zID0gdmVjMihjb3MoYSksIHNpbihhKSkgKiByMDtcbiAgICAgIGZsb2F0IGQgPSBkaXN0YW5jZSh1diwgcG9zKTtcbiAgICAgIGZsb2F0IHYxID0gbGlnaHQyKDEuNSwgNS4wLCBkKTtcbiAgICAgIHYxICo9IGxpZ2h0MSgxLjAsIDUwLjAsIGQwKTtcbiAgICAgIFxuICAgICAgZmxvYXQgdjIgPSBzbW9vdGhzdGVwKDEuMCwgbWl4KGlubmVyUmFkaXVzLCAxLjAsIG4wICogMC41KSwgbGVuKTtcbiAgICAgIGZsb2F0IHYzID0gc21vb3Roc3RlcChpbm5lclJhZGl1cywgbWl4KGlubmVyUmFkaXVzLCAxLjAsIDAuNSksIGxlbik7XG4gICAgICBcbiAgICAgIHZlYzMgY29sID0gbWl4KGNvbG9yMSwgY29sb3IyLCBjbCk7XG4gICAgICBjb2wgPSBtaXgoY29sb3IzLCBjb2wsIHYwKTtcbiAgICAgIGNvbCA9IChjb2wgKyB2MSkgKiB2MiAqIHYzO1xuICAgICAgY29sID0gY2xhbXAoY29sLCAwLjAsIDEuMCk7XG4gICAgICBcbiAgICAgIHZlYzQgb3JiQ29sb3IgPSBleHRyYWN0QWxwaGEoY29sKTtcblxuICAgICAgaWYgKGhhc1RleHR1cmUgPiAwLjUpIHtcbiAgICAgICAgdmVjMiB0ZXhVdiA9IHV2ICogMC41ICsgMC41O1xuICAgICAgICB2ZWM0IGF2YXRhckNvbG9yID0gdGV4dHVyZTJEKHRNYXAsIHRleFV2KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEJsZW5kIHRoZSBhdmF0YXIgd2l0aCB0aGUgb3JiIGVmZmVjdFxuICAgICAgICB2ZWMzIGZpbmFsQ29sb3IgPSBtaXgoYXZhdGFyQ29sb3IucmdiLCBvcmJDb2xvci5yZ2IsIG9yYkNvbG9yLmEgKiAwLjcpOyBcbiAgICAgICAgZmxvYXQgZmluYWxBbHBoYSA9IG9yYkNvbG9yLmE7XG5cbiAgICAgICAgcmV0dXJuIHZlYzQoZmluYWxDb2xvciwgZmluYWxBbHBoYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3JiQ29sb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmVjNCBtYWluSW1hZ2UodmVjMiBmcmFnQ29vcmQpIHtcbiAgICAgIHZlYzIgY2VudGVyID0gaVJlc29sdXRpb24ueHkgKiAwLjU7XG4gICAgICBmbG9hdCBzaXplID0gbWluKGlSZXNvbHV0aW9uLngsIGlSZXNvbHV0aW9uLnkpO1xuICAgICAgdmVjMiB1diA9IChmcmFnQ29vcmQgLSBjZW50ZXIpIC8gc2l6ZSAqIDIuMDtcbiAgICAgIFxuICAgICAgZmxvYXQgYW5nbGUgPSByb3Q7XG4gICAgICBmbG9hdCBzID0gc2luKGFuZ2xlKTtcbiAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGUpO1xuICAgICAgdXYgPSB2ZWMyKGMgKiB1di54IC0gcyAqIHV2LnksIHMgKiB1di54ICsgYyAqIHV2LnkpO1xuICAgICAgXG4gICAgICB1di54ICs9IGhvdmVyICogaG92ZXJJbnRlbnNpdHkgKiAwLjEgKiBzaW4odXYueSAqIDEwLjAgKyBpVGltZSk7XG4gICAgICB1di55ICs9IGhvdmVyICogaG92ZXJJbnRlbnNpdHkgKiAwLjEgKiBzaW4odXYueCAqIDEwLjAgKyBpVGltZSk7XG4gICAgICBcbiAgICAgIHJldHVybiBkcmF3KHV2KTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIGZyYWdDb29yZCA9IHZVdiAqIGlSZXNvbHV0aW9uLnh5O1xuICAgICAgdmVjNCBjb2wgPSBtYWluSW1hZ2UoZnJhZ0Nvb3JkKTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLnJnYiAqIGNvbC5hLCBjb2wuYSk7XG4gICAgfVxuICBgO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY3RuRG9tLmN1cnJlbnQ7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHsgYWxwaGE6IHRydWUsIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UgfSk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChnbC5jYW52YXMpO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsKTtcbiAgICBpZiAoYXZhdGFyVXJsKSB7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICBpbWcuc3JjID0gYXZhdGFyVXJsO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVHJpYW5nbGUoZ2wpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwge1xuICAgICAgdmVydGV4OiB2ZXJ0LFxuICAgICAgZnJhZ21lbnQ6IGZyYWcsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpVGltZTogeyB2YWx1ZTogMCB9LFxuICAgICAgICBpUmVzb2x1dGlvbjoge1xuICAgICAgICAgIHZhbHVlOiBuZXcgVmVjMyhcbiAgICAgICAgICAgIGdsLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGdsLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBnbC5jYW52YXMud2lkdGggLyBnbC5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgKSxcbiAgICAgICAgfSxcbiAgICAgICAgaHVlOiB7IHZhbHVlOiBodWUgfSxcbiAgICAgICAgaG92ZXI6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgcm90OiB7IHZhbHVlOiAwIH0sXG4gICAgICAgIGhvdmVySW50ZW5zaXR5OiB7IHZhbHVlOiBob3ZlckludGVuc2l0eSB9LFxuICAgICAgICB0TWFwOiB7IHZhbHVlOiB0ZXh0dXJlIH0sXG4gICAgICAgIGhhc1RleHR1cmU6IHsgdmFsdWU6IGF2YXRhclVybCA/IDEuMCA6IDAuMCB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnbCwgeyBnZW9tZXRyeSwgcHJvZ3JhbSB9KTtcblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGdsLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaVJlc29sdXRpb24udmFsdWUuc2V0KFxuICAgICAgICBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgIGdsLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgIGdsLmNhbnZhcy53aWR0aCAvIGdsLmNhbnZhcy5oZWlnaHRcbiAgICAgICk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZSk7XG4gICAgcmVzaXplKCk7XG5cbiAgICBsZXQgdGFyZ2V0SG92ZXIgPSAwO1xuICAgIGxldCBsYXN0VGltZSA9IDA7XG4gICAgbGV0IGN1cnJlbnRSb3QgPSAwO1xuICAgIGNvbnN0IHJvdGF0aW9uU3BlZWQgPSAwLjM7XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gd2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDI7XG4gICAgICBjb25zdCB1dlggPSAoKHggLSBjZW50ZXJYKSAvIHNpemUpICogMi4wO1xuICAgICAgY29uc3QgdXZZID0gKCh5IC0gY2VudGVyWSkgLyBzaXplKSAqIDIuMDtcblxuICAgICAgaWYgKE1hdGguc3FydCh1dlggKiB1dlggKyB1dlkgKiB1dlkpIDwgMC44KSB7XG4gICAgICAgIHRhcmdldEhvdmVyID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEhvdmVyID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICAgIHRhcmdldEhvdmVyID0gMDtcbiAgICB9O1xuXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlTW91c2VMZWF2ZSk7XG5cbiAgICBsZXQgcmFmSWQ6IG51bWJlcjtcbiAgICBjb25zdCB1cGRhdGUgPSAodDogbnVtYmVyKSA9PiB7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuICAgICAgY29uc3QgZHQgPSAodCAtIGxhc3RUaW1lKSAqIDAuMDAxO1xuICAgICAgbGFzdFRpbWUgPSB0O1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5pVGltZS52YWx1ZSA9IHQgKiAwLjAwMTtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaHVlLnZhbHVlID0gaHVlO1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5ob3ZlckludGVuc2l0eS52YWx1ZSA9IGhvdmVySW50ZW5zaXR5O1xuXG4gICAgICBjb25zdCBlZmZlY3RpdmVIb3ZlciA9IGZvcmNlSG92ZXJTdGF0ZSA/IDEgOiB0YXJnZXRIb3ZlcjtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaG92ZXIudmFsdWUgKz1cbiAgICAgICAgKGVmZmVjdGl2ZUhvdmVyIC0gcHJvZ3JhbS51bmlmb3Jtcy5ob3Zlci52YWx1ZSkgKiAwLjE7XG5cbiAgICAgIGlmIChyb3RhdGVPbkhvdmVyICYmIGVmZmVjdGl2ZUhvdmVyID4gMC41KSB7XG4gICAgICAgIGN1cnJlbnRSb3QgKz0gZHQgKiByb3RhdGlvblNwZWVkO1xuICAgICAgfVxuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5yb3QudmFsdWUgPSBjdXJyZW50Um90O1xuXG4gICAgICByZW5kZXJlci5yZW5kZXIoeyBzY2VuZTogbWVzaCB9KTtcbiAgICB9O1xuICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHJhZklkKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemUpO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlTW91c2VMZWF2ZSk7XG4gICAgICAgIGlmIChnbC5jYW52YXMucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGdsLmNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKT8ubG9zZUNvbnRleHQoKTtcbiAgICB9O1xuICB9LCBbYXZhdGFyVXJsLCBodWUsIGhvdmVySW50ZW5zaXR5LCByb3RhdGVPbkhvdmVyLCBmb3JjZUhvdmVyU3RhdGVdKTtcblxuICByZXR1cm4gPGRpdiByZWY9e2N0bkRvbX0gY2xhc3NOYW1lPVwib3JiLWNvbnRhaW5lclwiIC8+O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlJlbmRlcmVyIiwiUHJvZ3JhbSIsIk1lc2giLCJUcmlhbmdsZSIsIlZlYzMiLCJUZXh0dXJlIiwiT3JiIiwiaHVlIiwiaG92ZXJJbnRlbnNpdHkiLCJyb3RhdGVPbkhvdmVyIiwiZm9yY2VIb3ZlclN0YXRlIiwiYXZhdGFyVXJsIiwiY3RuRG9tIiwidmVydCIsImZyYWciLCJjb250YWluZXIiLCJjdXJyZW50IiwicmVuZGVyZXIiLCJhbHBoYSIsInByZW11bHRpcGxpZWRBbHBoYSIsImdsIiwiY2xlYXJDb2xvciIsImFwcGVuZENoaWxkIiwiY2FudmFzIiwidGV4dHVyZSIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJzcmMiLCJvbmxvYWQiLCJpbWFnZSIsImdlb21ldHJ5IiwicHJvZ3JhbSIsInZlcnRleCIsImZyYWdtZW50IiwidW5pZm9ybXMiLCJpVGltZSIsInZhbHVlIiwiaVJlc29sdXRpb24iLCJ3aWR0aCIsImhlaWdodCIsImhvdmVyIiwicm90IiwidE1hcCIsImhhc1RleHR1cmUiLCJtZXNoIiwicmVzaXplIiwiZHByIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2V0U2l6ZSIsInN0eWxlIiwic2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInRhcmdldEhvdmVyIiwibGFzdFRpbWUiLCJjdXJyZW50Um90Iiwicm90YXRpb25TcGVlZCIsImhhbmRsZU1vdXNlTW92ZSIsImUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJsZWZ0IiwieSIsImNsaWVudFkiLCJ0b3AiLCJzaXplIiwiTWF0aCIsIm1pbiIsImNlbnRlclgiLCJjZW50ZXJZIiwidXZYIiwidXZZIiwic3FydCIsImhhbmRsZU1vdXNlTGVhdmUiLCJyYWZJZCIsInVwZGF0ZSIsInQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkdCIsImVmZmVjdGl2ZUhvdmVyIiwicmVuZGVyIiwic2NlbmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJnZXRFeHRlbnNpb24iLCJsb3NlQ29udGV4dCIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Orb.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Texture.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Texture.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Texture: () => (/* binding */ Texture)\n/* harmony export */ });\n// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nclass Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n            length = 1,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.wrapR = wrapR;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.length = length;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.wrapR !== this.state.wrapR) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n            this.state.wrapR = this.wrapR;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n                } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n                }\n            } else {\n                // Regular texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n                }\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9vZ2xAMS4wLjExL25vZGVfbW9kdWxlcy9vZ2wvc3JjL2NvcmUvVGV4dHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMveWFuZ2p1bmNpL0RvY3VtZW50cy9HaXRIdWIvZnV5dW4tZGV2LXdlYnNpdGUvbm9kZV9tb2R1bGVzLy5wbnBtL29nbEAxLjAuMTEvbm9kZV9tb2R1bGVzL29nbC9zcmMvY29yZS9UZXh0dXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE86IGRlbGV0ZSB0ZXh0dXJlXG4vLyBUT0RPOiB1c2UgdGV4U3ViSW1hZ2UyRCBmb3IgdXBkYXRlcyAodmlkZW8gb3Igd2hlbiBsb2FkZWQpXG4vLyBUT0RPOiBuZWVkPyBlbmNvZGluZyA9IGxpbmVhckVuY29kaW5nXG4vLyBUT0RPOiBzdXBwb3J0IG5vbi1jb21wcmVzc2VkIG1pcG1hcHMgdXBsb2Fkc1xuXG5jb25zdCBlbXB0eVBpeGVsID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZjIodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYgKHZhbHVlIC0gMSkpID09PSAwO1xufVxuXG5sZXQgSUQgPSAxO1xuXG5leHBvcnQgY2xhc3MgVGV4dHVyZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGdsLFxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHRhcmdldCA9IGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGdsLlJHQkEsXG4gICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGZvcm1hdCxcbiAgICAgICAgICAgIHdyYXBTID0gZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIHdyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIHdyYXBSID0gZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwbWFwcyA9IHRhcmdldCA9PT0gKGdsLlRFWFRVUkVfMkQgfHwgZ2wuVEVYVFVSRV9DVUJFX01BUCksXG4gICAgICAgICAgICBtaW5GaWx0ZXIgPSBnZW5lcmF0ZU1pcG1hcHMgPyBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIgOiBnbC5MSU5FQVIsXG4gICAgICAgICAgICBtYWdGaWx0ZXIgPSBnbC5MSU5FQVIsXG4gICAgICAgICAgICBwcmVtdWx0aXBseUFscGhhID0gZmFsc2UsXG4gICAgICAgICAgICB1bnBhY2tBbGlnbm1lbnQgPSA0LFxuICAgICAgICAgICAgZmxpcFkgPSB0YXJnZXQgPT0gKGdsLlRFWFRVUkVfMkQgfHwgZ2wuVEVYVFVSRV8zRCkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICBhbmlzb3Ryb3B5ID0gMCxcbiAgICAgICAgICAgIGxldmVsID0gMCxcbiAgICAgICAgICAgIHdpZHRoLCAvLyB1c2VkIGZvciBSZW5kZXJUYXJnZXRzIG9yIERhdGEgVGV4dHVyZXNcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoLFxuICAgICAgICAgICAgbGVuZ3RoID0gMSxcbiAgICAgICAgfSA9IHt9XG4gICAgKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5pZCA9IElEKys7XG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdDtcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG4gICAgICAgIHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyO1xuICAgICAgICB0aGlzLndyYXBTID0gd3JhcFM7XG4gICAgICAgIHRoaXMud3JhcFQgPSB3cmFwVDtcbiAgICAgICAgdGhpcy53cmFwUiA9IHdyYXBSO1xuICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gcHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSB1bnBhY2tBbGlnbm1lbnQ7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBmbGlwWTtcbiAgICAgICAgdGhpcy5hbmlzb3Ryb3B5ID0gTWF0aC5taW4oYW5pc290cm9weSwgdGhpcy5nbC5yZW5kZXJlci5wYXJhbWV0ZXJzLm1heEFuaXNvdHJvcHkpO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICB0aGlzLnN0b3JlID0ge1xuICAgICAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWxpYXMgZm9yIHN0YXRlIHN0b3JlIHRvIGF2b2lkIHJlZHVuZGFudCBjYWxscyBmb3IgZ2xvYmFsIHN0YXRlXG4gICAgICAgIHRoaXMuZ2xTdGF0ZSA9IHRoaXMuZ2wucmVuZGVyZXIuc3RhdGU7XG5cbiAgICAgICAgLy8gU3RhdGUgc3RvcmUgdG8gYXZvaWQgcmVkdW5kYW50IGNhbGxzIGZvciBwZXItdGV4dHVyZSBzdGF0ZVxuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIHRoaXMuc3RhdGUubWluRmlsdGVyID0gdGhpcy5nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG4gICAgICAgIHRoaXMuc3RhdGUubWFnRmlsdGVyID0gdGhpcy5nbC5MSU5FQVI7XG4gICAgICAgIHRoaXMuc3RhdGUud3JhcFMgPSB0aGlzLmdsLlJFUEVBVDtcbiAgICAgICAgdGhpcy5zdGF0ZS53cmFwVCA9IHRoaXMuZ2wuUkVQRUFUO1xuICAgICAgICB0aGlzLnN0YXRlLmFuaXNvdHJvcHkgPSAwO1xuICAgIH1cblxuICAgIGJpbmQoKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYm91bmQgdG8gYWN0aXZlIHRleHR1cmUgdW5pdFxuICAgICAgICBpZiAodGhpcy5nbFN0YXRlLnRleHR1cmVVbml0c1t0aGlzLmdsU3RhdGUuYWN0aXZlVGV4dHVyZVVuaXRdID09PSB0aGlzLmlkKSByZXR1cm47XG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIHRoaXMuZ2xTdGF0ZS50ZXh0dXJlVW5pdHNbdGhpcy5nbFN0YXRlLmFjdGl2ZVRleHR1cmVVbml0XSA9IHRoaXMuaWQ7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRleHR1cmVVbml0ID0gMCkge1xuICAgICAgICBjb25zdCBuZWVkc1VwZGF0ZSA9ICEodGhpcy5pbWFnZSA9PT0gdGhpcy5zdG9yZS5pbWFnZSAmJiAhdGhpcy5uZWVkc1VwZGF0ZSk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGV4dHVyZSBpcyBib3VuZCB0byBpdHMgdGV4dHVyZSB1bml0XG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZSB8fCB0aGlzLmdsU3RhdGUudGV4dHVyZVVuaXRzW3RleHR1cmVVbml0XSAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgLy8gc2V0IGFjdGl2ZSB0ZXh0dXJlIHVuaXQgdG8gcGVyZm9ybSB0ZXh0dXJlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgdGhpcy5nbC5yZW5kZXJlci5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICAgICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZWVkc1VwZGF0ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuZmxpcFkgIT09IHRoaXMuZ2xTdGF0ZS5mbGlwWSkge1xuICAgICAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuZmxpcFkpO1xuICAgICAgICAgICAgdGhpcy5nbFN0YXRlLmZsaXBZID0gdGhpcy5mbGlwWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByZW11bHRpcGx5QWxwaGEgIT09IHRoaXMuZ2xTdGF0ZS5wcmVtdWx0aXBseUFscGhhKSB7XG4gICAgICAgICAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnByZW11bHRpcGx5QWxwaGEpO1xuICAgICAgICAgICAgdGhpcy5nbFN0YXRlLnByZW11bHRpcGx5QWxwaGEgPSB0aGlzLnByZW11bHRpcGx5QWxwaGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy51bnBhY2tBbGlnbm1lbnQgIT09IHRoaXMuZ2xTdGF0ZS51bnBhY2tBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfQUxJR05NRU5ULCB0aGlzLnVucGFja0FsaWdubWVudCk7XG4gICAgICAgICAgICB0aGlzLmdsU3RhdGUudW5wYWNrQWxpZ25tZW50ID0gdGhpcy51bnBhY2tBbGlnbm1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5taW5GaWx0ZXIgIT09IHRoaXMuc3RhdGUubWluRmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy50YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLm1pbkZpbHRlcik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFnRmlsdGVyICE9PSB0aGlzLnN0YXRlLm1hZ0ZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5tYWdGaWx0ZXIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLndyYXBTICE9PSB0aGlzLnN0YXRlLndyYXBTKSB7XG4gICAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy50YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS53cmFwUyA9IHRoaXMud3JhcFM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53cmFwVCAhPT0gdGhpcy5zdGF0ZS53cmFwVCkge1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUud3JhcFQgPSB0aGlzLndyYXBUO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMud3JhcFIgIT09IHRoaXMuc3RhdGUud3JhcFIpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRhcmdldCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUiwgdGhpcy53cmFwUik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLndyYXBSID0gdGhpcy53cmFwUjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuaXNvdHJvcHkgJiYgdGhpcy5hbmlzb3Ryb3B5ICE9PSB0aGlzLnN0YXRlLmFuaXNvdHJvcHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyZih0aGlzLnRhcmdldCwgdGhpcy5nbC5yZW5kZXJlci5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCB0aGlzLmFuaXNvdHJvcHkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSB0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgY3ViZSBtYXBzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgdGhpcy5sZXZlbCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgdGhpcy5pbWFnZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5pbWFnZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRhIHRleHR1cmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IHRoaXMuZ2wuVEVYVFVSRV8yRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy50YXJnZXQsIHRoaXMubGV2ZWwsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLmltYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09PSB0aGlzLmdsLlRFWFRVUkVfMkRfQVJSQVkgfHwgdGhpcy50YXJnZXQgPT09IHRoaXMuZ2wuVEVYVFVSRV8zRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnRleEltYWdlM0QodGhpcy50YXJnZXQsIHRoaXMubGV2ZWwsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmxlbmd0aCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgdGhpcy5pbWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmltYWdlLmlzQ29tcHJlc3NlZFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21wcmVzc2VkIHRleHR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5pbWFnZS5sZW5ndGg7IGxldmVsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCh0aGlzLnRhcmdldCwgbGV2ZWwsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMuaW1hZ2VbbGV2ZWxdLndpZHRoLCB0aGlzLmltYWdlW2xldmVsXS5oZWlnaHQsIDAsIHRoaXMuaW1hZ2VbbGV2ZWxdLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVndWxhciB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSB0aGlzLmdsLlRFWFRVUkVfMkQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMudGFyZ2V0LCB0aGlzLmxldmVsLCB0aGlzLmludGVybmFsRm9ybWF0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLmltYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnRleEltYWdlM0QodGhpcy50YXJnZXQsIHRoaXMubGV2ZWwsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmxlbmd0aCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgdGhpcy5pbWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZU1pcG1hcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgV2ViR0wxLCBpZiBub3QgYSBwb3dlciBvZiAyLCB0dXJuIG9mZiBtaXBzLCBzZXQgd3JhcHBpbmcgdG8gY2xhbXAgdG8gZWRnZSBhbmQgbWluRmlsdGVyIHRvIGxpbmVhclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nbC5yZW5kZXJlci5pc1dlYmdsMiAmJiAoIWlzUG93ZXJPZjIodGhpcy5pbWFnZS53aWR0aCkgfHwgIWlzUG93ZXJPZjIodGhpcy5pbWFnZS5oZWlnaHQpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBTID0gdGhpcy53cmFwVCA9IHRoaXMuZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSB0aGlzLmdsLkxJTkVBUjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciB3aGVuIGRhdGEgaXMgcHVzaGVkIHRvIEdQVVxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZSAmJiB0aGlzLm9uVXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IHRoaXMuZ2wuVEVYVFVSRV9DVUJFX01BUCkge1xuICAgICAgICAgICAgICAgIC8vIFVwbG9hZCBlbXB0eSBwaXhlbCBmb3IgZWFjaCBzaWRlIHdoaWxlIG5vIGltYWdlIHRvIGF2b2lkIGVycm9ycyB3aGlsZSBpbWFnZSBvciB2aWRlbyBsb2FkaW5nXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgdGhpcy5nbC5SR0JBLCAxLCAxLCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgZW1wdHlQaXhlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gaW1hZ2UgaW50ZW50aW9uYWxseSBsZWZ0IG51bGwgZm9yIFJlbmRlclRhcmdldFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gdGhpcy5nbC5URVhUVVJFXzJEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLnRhcmdldCwgdGhpcy5sZXZlbCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UzRCh0aGlzLnRhcmdldCwgdGhpcy5sZXZlbCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMubGVuZ3RoLCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVwbG9hZCBlbXB0eSBwaXhlbCBpZiBubyBpbWFnZSB0byBhdm9pZCBlcnJvcnMgd2hpbGUgaW1hZ2Ugb3IgdmlkZW8gbG9hZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLnRhcmdldCwgMCwgdGhpcy5nbC5SR0JBLCAxLCAxLCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgZW1wdHlQaXhlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZS5pbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Texture.js\n"));

/***/ })

});