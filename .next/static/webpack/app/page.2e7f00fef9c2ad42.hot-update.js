"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Orb.tsx":
/*!****************************!*\
  !*** ./components/Orb.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Orb)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Texture.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/math/Vec3.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/.pnpm/ogl@1.0.11/node_modules/ogl/src/core/Mesh.js\");\n/* harmony import */ var _Orb_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Orb.css */ \"(app-pages-browser)/./components/Orb.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction Orb(param) {\n    let { hue = 0, hoverIntensity = 0.2, rotationMode = 'hover', forceHoverState = false, avatarUrl } = param;\n    _s();\n    const ctnDom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const vert = \"\\n    precision highp float;\\n    attribute vec2 position;\\n    attribute vec2 uv;\\n    varying vec2 vUv;\\n    void main() {\\n      vUv = uv;\\n      gl_Position = vec4(position, 0.0, 1.0);\\n    }\\n  \";\n    const frag = \"\\n    precision highp float;\\n\\n    uniform float iTime;\\n    uniform vec3 iResolution;\\n    uniform float hue;\\n    uniform float hover;\\n    uniform float rot;\\n    uniform float hoverIntensity;\\n    uniform sampler2D tMap;\\n    uniform float hasTexture;\\n    varying vec2 vUv;\\n\\n    vec3 rgb2yiq(vec3 c) {\\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\\n      return vec3(y, i, q);\\n    }\\n    \\n    vec3 yiq2rgb(vec3 c) {\\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\\n      return vec3(r, g, b);\\n    }\\n    \\n    vec3 adjustHue(vec3 color, float hueDeg) {\\n      float hueRad = hueDeg * 3.14159265 / 180.0;\\n      vec3 yiq = rgb2yiq(color);\\n      float cosA = cos(hueRad);\\n      float sinA = sin(hueRad);\\n      float i = yiq.y * cosA - yiq.z * sinA;\\n      float q = yiq.y * sinA + yiq.z * cosA;\\n      yiq.y = i;\\n      yiq.z = q;\\n      return yiq2rgb(yiq);\\n    }\\n\\n    vec3 hash33(vec3 p3) {\\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\\n      p3 += dot(p3, p3.yxz + 19.19);\\n      return -1.0 + 2.0 * fract(vec3(\\n        p3.x + p3.y,\\n        p3.x + p3.z,\\n        p3.y + p3.z\\n      ) * p3.zyx);\\n    }\\n\\n    float snoise3(vec3 p) {\\n      const float K1 = 0.333333333;\\n      const float K2 = 0.166666667;\\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n      vec3 i1 = e * (1.0 - e.zxy);\\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n      vec3 d1 = d0 - (i1 - K2);\\n      vec3 d2 = d0 - (i2 - K1);\\n      vec3 d3 = d0 - 0.5;\\n      vec4 h = max(0.6 - vec4(\\n        dot(d0, d0),\\n        dot(d1, d1),\\n        dot(d2, d2),\\n        dot(d3, d3)\\n      ), 0.0);\\n      vec4 n = h * h * h * h * vec4(\\n        dot(d0, hash33(i)),\\n        dot(d1, hash33(i + i1)),\\n        dot(d2, hash33(i + i2)),\\n        dot(d3, hash33(i + 1.0))\\n      );\\n      return dot(vec4(31.316), n);\\n    }\\n\\n    vec4 extractAlpha(vec3 colorIn) {\\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\\n      return vec4(colorIn.rgb / (a + 1e-5), a);\\n    }\\n\\n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\\n    const float innerRadius = 0.6;\\n    const float noiseScale = 0.65;\\n\\n    float light1(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * attenuation);\\n    }\\n    float light2(float intensity, float attenuation, float dist) {\\n      return intensity / (1.0 + dist * dist * attenuation);\\n    }\\n\\n    vec4 draw(vec2 uv) {\\n      float ang = atan(uv.y, uv.x);\\n      float len = length(uv);\\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\\n      \\n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\\n      float d0 = distance(uv, (r0 * invLen) * uv);\\n      float v0 = light1(1.0, 10.0, d0);\\n      v0 *= smoothstep(r0 * 1.05, r0, len);\\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\\n      \\n      float a = iTime * -1.0;\\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\\n      float d = distance(uv, pos);\\n      float v1 = light2(1.5, 5.0, d);\\n      v1 *= light1(1.0, 50.0, d0);\\n      \\n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\\n      \\n      vec3 finalColor;\\n\\n      if (hasTexture > 0.5) {\\n        // Use Avatar as the base color\\n        vec2 avatarUV = uv * 0.5 + 0.5;\\n        vec3 avatarColor = texture2D(tMap, avatarUV).rgb;\\n        \\n        // Create a flowing cloud effect\\n        float cloudTime = iTime * 0.3;\\n        float cloudNoise = (snoise3(vec3(uv * 1.5, cloudTime)) + 1.0) * 0.5;\\n        cloudNoise = pow(cloudNoise, 2.5);\\n        vec3 cloudColor = vec3(1.0, 1.0, 1.0) * cloudNoise;\\n        \\n        // Blend the avatar with the clouds\\n        finalColor = mix(avatarColor, cloudColor, cloudNoise * 0.4);\\n\\n      } else {\\n        // Fallback to original procedural orb if no texture\\n        vec3 color1 = adjustHue(baseColor1, hue);\\n        vec3 color2 = adjustHue(baseColor2, hue);\\n        vec3 color3 = adjustHue(baseColor3, hue);\\n        vec3 col = mix(color1, color2, cl);\\n        col = mix(color3, col, v0);\\n        finalColor = (col + v1);\\n      }\\n      \\n      // Add a glowing edge (fresnel effect)\\n      float fresnel = smoothstep(0.8, 1.0, len) * 0.6;\\n      finalColor += fresnel;\\n\\n      // Apply the main orb shape and clamp colors\\n      finalColor *= v2;\\n      finalColor = clamp(finalColor, 0.0, 1.0);\\n      \\n      return extractAlpha(finalColor);\\n    }\\n\\n    vec4 mainImage(vec2 fragCoord) {\\n      vec2 center = iResolution.xy * 0.5;\\n      float size = min(iResolution.x, iResolution.y);\\n      vec2 uv = (fragCoord - center) / size * 2.0;\\n      \\n      float angle = rot;\\n      float s = sin(angle);\\n      float c = cos(angle);\\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\\n      \\n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\\n      \\n      return draw(uv);\\n    }\\n\\n    void main() {\\n      vec2 fragCoord = vUv * iResolution.xy;\\n      vec4 col = mainImage(fragCoord);\\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\\n    }\\n  \";\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Orb.useEffect\": ()=>{\n            const container = ctnDom.current;\n            if (!container) return;\n            const renderer = new ogl__WEBPACK_IMPORTED_MODULE_3__.Renderer({\n                alpha: true,\n                premultipliedAlpha: false\n            });\n            const gl = renderer.gl;\n            gl.clearColor(0, 0, 0, 0);\n            container.appendChild(gl.canvas);\n            const texture = new ogl__WEBPACK_IMPORTED_MODULE_4__.Texture(gl);\n            if (avatarUrl) {\n                const img = new Image();\n                img.crossOrigin = \"anonymous\";\n                img.src = avatarUrl;\n                img.onload = ({\n                    \"Orb.useEffect\": ()=>{\n                        texture.image = img;\n                    }\n                })[\"Orb.useEffect\"];\n            }\n            const geometry = new ogl__WEBPACK_IMPORTED_MODULE_5__.Triangle(gl);\n            const program = new ogl__WEBPACK_IMPORTED_MODULE_6__.Program(gl, {\n                vertex: vert,\n                fragment: frag,\n                uniforms: {\n                    iTime: {\n                        value: 0\n                    },\n                    iResolution: {\n                        value: new ogl__WEBPACK_IMPORTED_MODULE_7__.Vec3(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\n                    },\n                    hue: {\n                        value: hue\n                    },\n                    hover: {\n                        value: 0\n                    },\n                    rot: {\n                        value: 0\n                    },\n                    hoverIntensity: {\n                        value: hoverIntensity\n                    },\n                    tMap: {\n                        value: texture\n                    },\n                    hasTexture: {\n                        value: avatarUrl ? 1.0 : 0.0\n                    }\n                }\n            });\n            const mesh = new ogl__WEBPACK_IMPORTED_MODULE_8__.Mesh(gl, {\n                geometry,\n                program\n            });\n            function resize() {\n                if (!container) return;\n                const dpr = window.devicePixelRatio || 1;\n                const width = container.clientWidth;\n                const height = container.clientHeight;\n                renderer.setSize(width * dpr, height * dpr);\n                gl.canvas.style.width = width + \"px\";\n                gl.canvas.style.height = height + \"px\";\n                program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height);\n            }\n            window.addEventListener(\"resize\", resize);\n            resize();\n            let targetHover = 0;\n            let lastTime = 0;\n            let currentRot = 0;\n            const autoRotationSpeed = 0.1;\n            const hoverRotationSpeed = 0.3;\n            const handleMouseMove = {\n                \"Orb.useEffect.handleMouseMove\": (e)=>{\n                    if (!container) return;\n                    const rect = container.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    const width = rect.width;\n                    const height = rect.height;\n                    const size = Math.min(width, height);\n                    const centerX = width / 2;\n                    const centerY = height / 2;\n                    const uvX = (x - centerX) / size * 2.0;\n                    const uvY = (y - centerY) / size * 2.0;\n                    if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n                        targetHover = 1;\n                    } else {\n                        targetHover = 0;\n                    }\n                }\n            }[\"Orb.useEffect.handleMouseMove\"];\n            const handleMouseLeave = {\n                \"Orb.useEffect.handleMouseLeave\": ()=>{\n                    targetHover = 0;\n                }\n            }[\"Orb.useEffect.handleMouseLeave\"];\n            container.addEventListener(\"mousemove\", handleMouseMove);\n            container.addEventListener(\"mouseleave\", handleMouseLeave);\n            let rafId;\n            const update = {\n                \"Orb.useEffect.update\": (t)=>{\n                    rafId = requestAnimationFrame(update);\n                    const dt = (t - lastTime) * 0.001;\n                    lastTime = t;\n                    program.uniforms.iTime.value = t * 0.001;\n                    program.uniforms.hue.value = hue;\n                    program.uniforms.hoverIntensity.value = hoverIntensity;\n                    const effectiveHover = forceHoverState ? 1 : targetHover;\n                    program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n                    if (rotationMode === 'auto') {\n                        currentRot += dt * autoRotationSpeed;\n                    } else if (rotationMode === 'hover' && effectiveHover > 0.5) {\n                        currentRot += dt * hoverRotationSpeed;\n                    }\n                    program.uniforms.rot.value = currentRot;\n                    renderer.render({\n                        scene: mesh\n                    });\n                }\n            }[\"Orb.useEffect.update\"];\n            rafId = requestAnimationFrame(update);\n            return ({\n                \"Orb.useEffect\": ()=>{\n                    var _gl_getExtension;\n                    if (rafId) cancelAnimationFrame(rafId);\n                    window.removeEventListener(\"resize\", resize);\n                    if (container) {\n                        container.removeEventListener(\"mousemove\", handleMouseMove);\n                        container.removeEventListener(\"mouseleave\", handleMouseLeave);\n                        if (gl.canvas.parentNode === container) {\n                            container.removeChild(gl.canvas);\n                        }\n                    }\n                    (_gl_getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl_getExtension === void 0 ? void 0 : _gl_getExtension.loseContext();\n                }\n            })[\"Orb.useEffect\"];\n        }\n    }[\"Orb.useEffect\"], [\n        avatarUrl,\n        hue,\n        hoverIntensity,\n        rotationMode,\n        forceHoverState\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ctnDom,\n        className: \"orb-container\"\n    }, void 0, false, {\n        fileName: \"/Users/yangjunci/Documents/GitHub/fuyun-dev-website/components/Orb.tsx\",\n        lineNumber: 338,\n        columnNumber: 10\n    }, this);\n}\n_s(Orb, \"RK9NRNXyqwE64a4o6Ka2phRjmok=\");\n_c = Orb;\nvar _c;\n$RefreshReg$(_c, \"Orb\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvT3JiLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQzBDO0FBQzZCO0FBRXBEO0FBRUosU0FBU1EsSUFBSSxLQVkzQjtRQVoyQixFQUMxQkMsTUFBTSxDQUFDLEVBQ1BDLGlCQUFpQixHQUFHLEVBQ3BCQyxlQUFlLE9BQU8sRUFDdEJDLGtCQUFrQixLQUFLLEVBQ3ZCQyxTQUFTLEVBT1YsR0FaMkI7O0lBYTFCLE1BQU1DLFNBQVNiLDZDQUFNQSxDQUFpQjtJQUV0QyxNQUFNYyxPQUFtQjtJQVd6QixNQUFNQyxPQUFtQjtJQTZLekJoQixnREFBU0E7eUJBQUM7WUFDUixNQUFNaUIsWUFBWUgsT0FBT0ksT0FBTztZQUNoQyxJQUFJLENBQUNELFdBQVc7WUFFaEIsTUFBTUUsV0FBVyxJQUFJakIseUNBQVFBLENBQUM7Z0JBQUVrQixPQUFPO2dCQUFNQyxvQkFBb0I7WUFBTTtZQUN2RSxNQUFNQyxLQUFLSCxTQUFTRyxFQUFFO1lBQ3RCQSxHQUFHQyxVQUFVLENBQUMsR0FBRyxHQUFHLEdBQUc7WUFDdkJOLFVBQVVPLFdBQVcsQ0FBQ0YsR0FBR0csTUFBTTtZQUUvQixNQUFNQyxVQUFVLElBQUluQix3Q0FBT0EsQ0FBQ2U7WUFDNUIsSUFBSVQsV0FBVztnQkFDYixNQUFNYyxNQUFNLElBQUlDO2dCQUNoQkQsSUFBSUUsV0FBVyxHQUFHO2dCQUNsQkYsSUFBSUcsR0FBRyxHQUFHakI7Z0JBQ1ZjLElBQUlJLE1BQU07cUNBQUc7d0JBQ1hMLFFBQVFNLEtBQUssR0FBR0w7b0JBQ2xCOztZQUNGO1lBRUEsTUFBTU0sV0FBVyxJQUFJNUIseUNBQVFBLENBQUNpQjtZQUM5QixNQUFNWSxVQUFVLElBQUkvQix3Q0FBT0EsQ0FBQ21CLElBQUk7Z0JBQzlCYSxRQUFRcEI7Z0JBQ1JxQixVQUFVcEI7Z0JBQ1ZxQixVQUFVO29CQUNSQyxPQUFPO3dCQUFFQyxPQUFPO29CQUFFO29CQUNsQkMsYUFBYTt3QkFD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QUFnQkM7UUFBY0M7S0FBZ0I7SUFFbEUscUJBQU8sOERBQUNvRjtRQUFJQyxLQUFLbkY7UUFBUW9GLFdBQVU7Ozs7OztBQUNyQztHQTVVd0IxRjtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL3lhbmdqdW5jaS9Eb2N1bWVudHMvR2l0SHViL2Z1eXVuLWRldi13ZWJzaXRlL2NvbXBvbmVudHMvT3JiLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBSZW5kZXJlciwgUHJvZ3JhbSwgTWVzaCwgVHJpYW5nbGUsIFZlYzMsIFRleHR1cmUgfSBmcm9tIFwib2dsXCI7XG5cbmltcG9ydCBcIi4vT3JiLmNzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPcmIoe1xuICBodWUgPSAwLFxuICBob3ZlckludGVuc2l0eSA9IDAuMixcbiAgcm90YXRpb25Nb2RlID0gJ2hvdmVyJyxcbiAgZm9yY2VIb3ZlclN0YXRlID0gZmFsc2UsXG4gIGF2YXRhclVybCxcbn06IHtcbiAgaHVlPzogbnVtYmVyO1xuICBob3ZlckludGVuc2l0eT86IG51bWJlcjtcbiAgcm90YXRpb25Nb2RlPzogJ2F1dG8nIHwgJ2hvdmVyJyB8ICdub25lJztcbiAgZm9yY2VIb3ZlclN0YXRlPzogYm9vbGVhbjtcbiAgYXZhdGFyVXJsPzogc3RyaW5nO1xufSkge1xuICBjb25zdCBjdG5Eb20gPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuXG4gIGNvbnN0IHZlcnQgPSAvKiBnbHNsICovIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2VXYgPSB1djtcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgIH1cbiAgYDtcblxuICBjb25zdCBmcmFnID0gLyogZ2xzbCAqLyBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBmbG9hdCBpVGltZTtcbiAgICB1bmlmb3JtIHZlYzMgaVJlc29sdXRpb247XG4gICAgdW5pZm9ybSBmbG9hdCBodWU7XG4gICAgdW5pZm9ybSBmbG9hdCBob3ZlcjtcbiAgICB1bmlmb3JtIGZsb2F0IHJvdDtcbiAgICB1bmlmb3JtIGZsb2F0IGhvdmVySW50ZW5zaXR5O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRNYXA7XG4gICAgdW5pZm9ybSBmbG9hdCBoYXNUZXh0dXJlO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgICB2ZWMzIHJnYjJ5aXEodmVjMyBjKSB7XG4gICAgICBmbG9hdCB5ID0gZG90KGMsIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xuICAgICAgZmxvYXQgaSA9IGRvdChjLCB2ZWMzKDAuNTk2LCAtMC4yNzQsIC0wLjMyMikpO1xuICAgICAgZmxvYXQgcSA9IGRvdChjLCB2ZWMzKDAuMjExLCAtMC41MjMsIDAuMzEyKSk7XG4gICAgICByZXR1cm4gdmVjMyh5LCBpLCBxKTtcbiAgICB9XG4gICAgXG4gICAgdmVjMyB5aXEycmdiKHZlYzMgYykge1xuICAgICAgZmxvYXQgciA9IGMueCArIDAuOTU2ICogYy55ICsgMC42MjEgKiBjLno7XG4gICAgICBmbG9hdCBnID0gYy54IC0gMC4yNzIgKiBjLnkgLSAwLjY0NyAqIGMuejtcbiAgICAgIGZsb2F0IGIgPSBjLnggLSAxLjEwNiAqIGMueSArIDEuNzAzICogYy56O1xuICAgICAgcmV0dXJuIHZlYzMociwgZywgYik7XG4gICAgfVxuICAgIFxuICAgIHZlYzMgYWRqdXN0SHVlKHZlYzMgY29sb3IsIGZsb2F0IGh1ZURlZykge1xuICAgICAgZmxvYXQgaHVlUmFkID0gaHVlRGVnICogMy4xNDE1OTI2NSAvIDE4MC4wO1xuICAgICAgdmVjMyB5aXEgPSByZ2IyeWlxKGNvbG9yKTtcbiAgICAgIGZsb2F0IGNvc0EgPSBjb3MoaHVlUmFkKTtcbiAgICAgIGZsb2F0IHNpbkEgPSBzaW4oaHVlUmFkKTtcbiAgICAgIGZsb2F0IGkgPSB5aXEueSAqIGNvc0EgLSB5aXEueiAqIHNpbkE7XG4gICAgICBmbG9hdCBxID0geWlxLnkgKiBzaW5BICsgeWlxLnogKiBjb3NBO1xuICAgICAgeWlxLnkgPSBpO1xuICAgICAgeWlxLnogPSBxO1xuICAgICAgcmV0dXJuIHlpcTJyZ2IoeWlxKTtcbiAgICB9XG5cbiAgICB2ZWMzIGhhc2gzMyh2ZWMzIHAzKSB7XG4gICAgICBwMyA9IGZyYWN0KHAzICogdmVjMygwLjEwMzEsIDAuMTEzNjksIDAuMTM3ODcpKTtcbiAgICAgIHAzICs9IGRvdChwMywgcDMueXh6ICsgMTkuMTkpO1xuICAgICAgcmV0dXJuIC0xLjAgKyAyLjAgKiBmcmFjdCh2ZWMzKFxuICAgICAgICBwMy54ICsgcDMueSxcbiAgICAgICAgcDMueCArIHAzLnosXG4gICAgICAgIHAzLnkgKyBwMy56XG4gICAgICApICogcDMuenl4KTtcbiAgICB9XG5cbiAgICBmbG9hdCBzbm9pc2UzKHZlYzMgcCkge1xuICAgICAgY29uc3QgZmxvYXQgSzEgPSAwLjMzMzMzMzMzMztcbiAgICAgIGNvbnN0IGZsb2F0IEsyID0gMC4xNjY2NjY2Njc7XG4gICAgICB2ZWMzIGkgPSBmbG9vcihwICsgKHAueCArIHAueSArIHAueikgKiBLMSk7XG4gICAgICB2ZWMzIGQwID0gcCAtIChpIC0gKGkueCArIGkueSArIGkueikgKiBLMik7XG4gICAgICB2ZWMzIGUgPSBzdGVwKHZlYzMoMC4wKSwgZDAgLSBkMC55engpO1xuICAgICAgdmVjMyBpMSA9IGUgKiAoMS4wIC0gZS56eHkpO1xuICAgICAgdmVjMyBpMiA9IDEuMCAtIGUuenh5ICogKDEuMCAtIGUpO1xuICAgICAgdmVjMyBkMSA9IGQwIC0gKGkxIC0gSzIpO1xuICAgICAgdmVjMyBkMiA9IGQwIC0gKGkyIC0gSzEpO1xuICAgICAgdmVjMyBkMyA9IGQwIC0gMC41O1xuICAgICAgdmVjNCBoID0gbWF4KDAuNiAtIHZlYzQoXG4gICAgICAgIGRvdChkMCwgZDApLFxuICAgICAgICBkb3QoZDEsIGQxKSxcbiAgICAgICAgZG90KGQyLCBkMiksXG4gICAgICAgIGRvdChkMywgZDMpXG4gICAgICApLCAwLjApO1xuICAgICAgdmVjNCBuID0gaCAqIGggKiBoICogaCAqIHZlYzQoXG4gICAgICAgIGRvdChkMCwgaGFzaDMzKGkpKSxcbiAgICAgICAgZG90KGQxLCBoYXNoMzMoaSArIGkxKSksXG4gICAgICAgIGRvdChkMiwgaGFzaDMzKGkgKyBpMikpLFxuICAgICAgICBkb3QoZDMsIGhhc2gzMyhpICsgMS4wKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG90KHZlYzQoMzEuMzE2KSwgbik7XG4gICAgfVxuXG4gICAgdmVjNCBleHRyYWN0QWxwaGEodmVjMyBjb2xvckluKSB7XG4gICAgICBmbG9hdCBhID0gbWF4KG1heChjb2xvckluLnIsIGNvbG9ySW4uZyksIGNvbG9ySW4uYik7XG4gICAgICByZXR1cm4gdmVjNChjb2xvckluLnJnYiAvIChhICsgMWUtNSksIGEpO1xuICAgIH1cblxuICAgIGNvbnN0IHZlYzMgYmFzZUNvbG9yMSA9IHZlYzMoMC42MTE3NjUsIDAuMjYyNzQ1LCAwLjk5NjA3OCk7XG4gICAgY29uc3QgdmVjMyBiYXNlQ29sb3IyID0gdmVjMygwLjI5ODAzOSwgMC43NjA3ODQsIDAuOTEzNzI1KTtcbiAgICBjb25zdCB2ZWMzIGJhc2VDb2xvcjMgPSB2ZWMzKDAuMDYyNzQ1LCAwLjA3ODQzMSwgMC42MDAwMDApO1xuICAgIGNvbnN0IGZsb2F0IGlubmVyUmFkaXVzID0gMC42O1xuICAgIGNvbnN0IGZsb2F0IG5vaXNlU2NhbGUgPSAwLjY1O1xuXG4gICAgZmxvYXQgbGlnaHQxKGZsb2F0IGludGVuc2l0eSwgZmxvYXQgYXR0ZW51YXRpb24sIGZsb2F0IGRpc3QpIHtcbiAgICAgIHJldHVybiBpbnRlbnNpdHkgLyAoMS4wICsgZGlzdCAqIGF0dGVudWF0aW9uKTtcbiAgICB9XG4gICAgZmxvYXQgbGlnaHQyKGZsb2F0IGludGVuc2l0eSwgZmxvYXQgYXR0ZW51YXRpb24sIGZsb2F0IGRpc3QpIHtcbiAgICAgIHJldHVybiBpbnRlbnNpdHkgLyAoMS4wICsgZGlzdCAqIGRpc3QgKiBhdHRlbnVhdGlvbik7XG4gICAgfVxuXG4gICAgdmVjNCBkcmF3KHZlYzIgdXYpIHtcbiAgICAgIGZsb2F0IGFuZyA9IGF0YW4odXYueSwgdXYueCk7XG4gICAgICBmbG9hdCBsZW4gPSBsZW5ndGgodXYpO1xuICAgICAgZmxvYXQgaW52TGVuID0gbGVuID4gMC4wID8gMS4wIC8gbGVuIDogMC4wO1xuICAgICAgXG4gICAgICBmbG9hdCBuMCA9IHNub2lzZTModmVjMyh1diAqIG5vaXNlU2NhbGUsIGlUaW1lICogMC41KSkgKiAwLjUgKyAwLjU7XG4gICAgICBmbG9hdCByMCA9IG1peChtaXgoaW5uZXJSYWRpdXMsIDEuMCwgMC40KSwgbWl4KGlubmVyUmFkaXVzLCAxLjAsIDAuNiksIG4wKTtcbiAgICAgIGZsb2F0IGQwID0gZGlzdGFuY2UodXYsIChyMCAqIGludkxlbikgKiB1dik7XG4gICAgICBmbG9hdCB2MCA9IGxpZ2h0MSgxLjAsIDEwLjAsIGQwKTtcbiAgICAgIHYwICo9IHNtb290aHN0ZXAocjAgKiAxLjA1LCByMCwgbGVuKTtcbiAgICAgIGZsb2F0IGNsID0gY29zKGFuZyArIGlUaW1lICogMi4wKSAqIDAuNSArIDAuNTtcbiAgICAgIFxuICAgICAgZmxvYXQgYSA9IGlUaW1lICogLTEuMDtcbiAgICAgIHZlYzIgcG9zID0gdmVjMihjb3MoYSksIHNpbihhKSkgKiByMDtcbiAgICAgIGZsb2F0IGQgPSBkaXN0YW5jZSh1diwgcG9zKTtcbiAgICAgIGZsb2F0IHYxID0gbGlnaHQyKDEuNSwgNS4wLCBkKTtcbiAgICAgIHYxICo9IGxpZ2h0MSgxLjAsIDUwLjAsIGQwKTtcbiAgICAgIFxuICAgICAgZmxvYXQgdjIgPSBzbW9vdGhzdGVwKDEuMCwgbWl4KGlubmVyUmFkaXVzLCAxLjAsIG4wICogMC41KSwgbGVuKTtcbiAgICAgIFxuICAgICAgdmVjMyBmaW5hbENvbG9yO1xuXG4gICAgICBpZiAoaGFzVGV4dHVyZSA+IDAuNSkge1xuICAgICAgICAvLyBVc2UgQXZhdGFyIGFzIHRoZSBiYXNlIGNvbG9yXG4gICAgICAgIHZlYzIgYXZhdGFyVVYgPSB1diAqIDAuNSArIDAuNTtcbiAgICAgICAgdmVjMyBhdmF0YXJDb2xvciA9IHRleHR1cmUyRCh0TWFwLCBhdmF0YXJVVikucmdiO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgZmxvd2luZyBjbG91ZCBlZmZlY3RcbiAgICAgICAgZmxvYXQgY2xvdWRUaW1lID0gaVRpbWUgKiAwLjM7XG4gICAgICAgIGZsb2F0IGNsb3VkTm9pc2UgPSAoc25vaXNlMyh2ZWMzKHV2ICogMS41LCBjbG91ZFRpbWUpKSArIDEuMCkgKiAwLjU7XG4gICAgICAgIGNsb3VkTm9pc2UgPSBwb3coY2xvdWROb2lzZSwgMi41KTtcbiAgICAgICAgdmVjMyBjbG91ZENvbG9yID0gdmVjMygxLjAsIDEuMCwgMS4wKSAqIGNsb3VkTm9pc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBCbGVuZCB0aGUgYXZhdGFyIHdpdGggdGhlIGNsb3Vkc1xuICAgICAgICBmaW5hbENvbG9yID0gbWl4KGF2YXRhckNvbG9yLCBjbG91ZENvbG9yLCBjbG91ZE5vaXNlICogMC40KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gb3JpZ2luYWwgcHJvY2VkdXJhbCBvcmIgaWYgbm8gdGV4dHVyZVxuICAgICAgICB2ZWMzIGNvbG9yMSA9IGFkanVzdEh1ZShiYXNlQ29sb3IxLCBodWUpO1xuICAgICAgICB2ZWMzIGNvbG9yMiA9IGFkanVzdEh1ZShiYXNlQ29sb3IyLCBodWUpO1xuICAgICAgICB2ZWMzIGNvbG9yMyA9IGFkanVzdEh1ZShiYXNlQ29sb3IzLCBodWUpO1xuICAgICAgICB2ZWMzIGNvbCA9IG1peChjb2xvcjEsIGNvbG9yMiwgY2wpO1xuICAgICAgICBjb2wgPSBtaXgoY29sb3IzLCBjb2wsIHYwKTtcbiAgICAgICAgZmluYWxDb2xvciA9IChjb2wgKyB2MSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIGdsb3dpbmcgZWRnZSAoZnJlc25lbCBlZmZlY3QpXG4gICAgICBmbG9hdCBmcmVzbmVsID0gc21vb3Roc3RlcCgwLjgsIDEuMCwgbGVuKSAqIDAuNjtcbiAgICAgIGZpbmFsQ29sb3IgKz0gZnJlc25lbDtcblxuICAgICAgLy8gQXBwbHkgdGhlIG1haW4gb3JiIHNoYXBlIGFuZCBjbGFtcCBjb2xvcnNcbiAgICAgIGZpbmFsQ29sb3IgKj0gdjI7XG4gICAgICBmaW5hbENvbG9yID0gY2xhbXAoZmluYWxDb2xvciwgMC4wLCAxLjApO1xuICAgICAgXG4gICAgICByZXR1cm4gZXh0cmFjdEFscGhhKGZpbmFsQ29sb3IpO1xuICAgIH1cblxuICAgIHZlYzQgbWFpbkltYWdlKHZlYzIgZnJhZ0Nvb3JkKSB7XG4gICAgICB2ZWMyIGNlbnRlciA9IGlSZXNvbHV0aW9uLnh5ICogMC41O1xuICAgICAgZmxvYXQgc2l6ZSA9IG1pbihpUmVzb2x1dGlvbi54LCBpUmVzb2x1dGlvbi55KTtcbiAgICAgIHZlYzIgdXYgPSAoZnJhZ0Nvb3JkIC0gY2VudGVyKSAvIHNpemUgKiAyLjA7XG4gICAgICBcbiAgICAgIGZsb2F0IGFuZ2xlID0gcm90O1xuICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZSk7XG4gICAgICBmbG9hdCBjID0gY29zKGFuZ2xlKTtcbiAgICAgIHV2ID0gdmVjMihjICogdXYueCAtIHMgKiB1di55LCBzICogdXYueCArIGMgKiB1di55KTtcbiAgICAgIFxuICAgICAgdXYueCArPSBob3ZlciAqIGhvdmVySW50ZW5zaXR5ICogMC4xICogc2luKHV2LnkgKiAxMC4wICsgaVRpbWUpO1xuICAgICAgdXYueSArPSBob3ZlciAqIGhvdmVySW50ZW5zaXR5ICogMC4xICogc2luKHV2LnggKiAxMC4wICsgaVRpbWUpO1xuICAgICAgXG4gICAgICByZXR1cm4gZHJhdyh1dik7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiBmcmFnQ29vcmQgPSB2VXYgKiBpUmVzb2x1dGlvbi54eTtcbiAgICAgIHZlYzQgY29sID0gbWFpbkltYWdlKGZyYWdDb29yZCk7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbC5yZ2IgKiBjb2wuYSwgY29sLmEpO1xuICAgIH1cbiAgYDtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGN0bkRvbS5jdXJyZW50O1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7IGFscGhhOiB0cnVlLCBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2wuY2FudmFzKTtcblxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCk7XG4gICAgaWYgKGF2YXRhclVybCkge1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgaW1nLnNyYyA9IGF2YXRhclVybDtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRyaWFuZ2xlKGdsKTtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHtcbiAgICAgIHZlcnRleDogdmVydCxcbiAgICAgIGZyYWdtZW50OiBmcmFnLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaVRpbWU6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgaVJlc29sdXRpb246IHtcbiAgICAgICAgICB2YWx1ZTogbmV3IFZlYzMoXG4gICAgICAgICAgICBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICBnbC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgZ2wuY2FudmFzLndpZHRoIC8gZ2wuY2FudmFzLmhlaWdodFxuICAgICAgICAgICksXG4gICAgICAgIH0sXG4gICAgICAgIGh1ZTogeyB2YWx1ZTogaHVlIH0sXG4gICAgICAgIGhvdmVyOiB7IHZhbHVlOiAwIH0sXG4gICAgICAgIHJvdDogeyB2YWx1ZTogMCB9LFxuICAgICAgICBob3ZlckludGVuc2l0eTogeyB2YWx1ZTogaG92ZXJJbnRlbnNpdHkgfSxcbiAgICAgICAgdE1hcDogeyB2YWx1ZTogdGV4dHVyZSB9LFxuICAgICAgICBoYXNUZXh0dXJlOiB7IHZhbHVlOiBhdmF0YXJVcmwgPyAxLjAgOiAwLjAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2wsIHsgZ2VvbWV0cnksIHByb2dyYW0gfSk7XG5cbiAgICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgICAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICBnbC5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgIGdsLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLmlSZXNvbHV0aW9uLnZhbHVlLnNldChcbiAgICAgICAgZ2wuY2FudmFzLndpZHRoLFxuICAgICAgICBnbC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICBnbC5jYW52YXMud2lkdGggLyBnbC5jYW52YXMuaGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemUpO1xuICAgIHJlc2l6ZSgpO1xuXG4gICAgbGV0IHRhcmdldEhvdmVyID0gMDtcbiAgICBsZXQgbGFzdFRpbWUgPSAwO1xuICAgIGxldCBjdXJyZW50Um90ID0gMDtcbiAgICBjb25zdCBhdXRvUm90YXRpb25TcGVlZCA9IDAuMTtcbiAgICBjb25zdCBob3ZlclJvdGF0aW9uU3BlZWQgPSAwLjM7XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gd2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDI7XG4gICAgICBjb25zdCB1dlggPSAoKHggLSBjZW50ZXJYKSAvIHNpemUpICogMi4wO1xuICAgICAgY29uc3QgdXZZID0gKCh5IC0gY2VudGVyWSkgLyBzaXplKSAqIDIuMDtcblxuICAgICAgaWYgKE1hdGguc3FydCh1dlggKiB1dlggKyB1dlkgKiB1dlkpIDwgMC44KSB7XG4gICAgICAgIHRhcmdldEhvdmVyID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEhvdmVyID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICAgIHRhcmdldEhvdmVyID0gMDtcbiAgICB9O1xuXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlTW91c2VMZWF2ZSk7XG5cbiAgICBsZXQgcmFmSWQ6IG51bWJlcjtcbiAgICBjb25zdCB1cGRhdGUgPSAodDogbnVtYmVyKSA9PiB7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuICAgICAgY29uc3QgZHQgPSAodCAtIGxhc3RUaW1lKSAqIDAuMDAxO1xuICAgICAgbGFzdFRpbWUgPSB0O1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5pVGltZS52YWx1ZSA9IHQgKiAwLjAwMTtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaHVlLnZhbHVlID0gaHVlO1xuICAgICAgcHJvZ3JhbS51bmlmb3Jtcy5ob3ZlckludGVuc2l0eS52YWx1ZSA9IGhvdmVySW50ZW5zaXR5O1xuXG4gICAgICBjb25zdCBlZmZlY3RpdmVIb3ZlciA9IGZvcmNlSG92ZXJTdGF0ZSA/IDEgOiB0YXJnZXRIb3ZlcjtcbiAgICAgIHByb2dyYW0udW5pZm9ybXMuaG92ZXIudmFsdWUgKz1cbiAgICAgICAgKGVmZmVjdGl2ZUhvdmVyIC0gcHJvZ3JhbS51bmlmb3Jtcy5ob3Zlci52YWx1ZSkgKiAwLjE7XG5cbiAgICAgIGlmIChyb3RhdGlvbk1vZGUgPT09ICdhdXRvJykge1xuICAgICAgICBjdXJyZW50Um90ICs9IGR0ICogYXV0b1JvdGF0aW9uU3BlZWQ7XG4gICAgICB9IGVsc2UgaWYgKHJvdGF0aW9uTW9kZSA9PT0gJ2hvdmVyJyAmJiBlZmZlY3RpdmVIb3ZlciA+IDAuNSkge1xuICAgICAgICBjdXJyZW50Um90ICs9IGR0ICogaG92ZXJSb3RhdGlvblNwZWVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICBwcm9ncmFtLnVuaWZvcm1zLnJvdC52YWx1ZSA9IGN1cnJlbnRSb3Q7XG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlcih7IHNjZW5lOiBtZXNoIH0pO1xuICAgIH07XG4gICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmFmSWQpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZSk7XG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBoYW5kbGVNb3VzZUxlYXZlKTtcbiAgICAgICAgaWYgKGdsLmNhbnZhcy5wYXJlbnROb2RlID09PSBjb250YWluZXIpIHtcbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoZ2wuY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpPy5sb3NlQ29udGV4dCgpO1xuICAgIH07XG4gIH0sIFthdmF0YXJVcmwsIGh1ZSwgaG92ZXJJbnRlbnNpdHksIHJvdGF0aW9uTW9kZSwgZm9yY2VIb3ZlclN0YXRlXSk7XG5cbiAgcmV0dXJuIDxkaXYgcmVmPXtjdG5Eb219IGNsYXNzTmFtZT1cIm9yYi1jb250YWluZXJcIiAvPjtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJSZW5kZXJlciIsIlByb2dyYW0iLCJNZXNoIiwiVHJpYW5nbGUiLCJWZWMzIiwiVGV4dHVyZSIsIk9yYiIsImh1ZSIsImhvdmVySW50ZW5zaXR5Iiwicm90YXRpb25Nb2RlIiwiZm9yY2VIb3ZlclN0YXRlIiwiYXZhdGFyVXJsIiwiY3RuRG9tIiwidmVydCIsImZyYWciLCJjb250YWluZXIiLCJjdXJyZW50IiwicmVuZGVyZXIiLCJhbHBoYSIsInByZW11bHRpcGxpZWRBbHBoYSIsImdsIiwiY2xlYXJDb2xvciIsImFwcGVuZENoaWxkIiwiY2FudmFzIiwidGV4dHVyZSIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJzcmMiLCJvbmxvYWQiLCJpbWFnZSIsImdlb21ldHJ5IiwicHJvZ3JhbSIsInZlcnRleCIsImZyYWdtZW50IiwidW5pZm9ybXMiLCJpVGltZSIsInZhbHVlIiwiaVJlc29sdXRpb24iLCJ3aWR0aCIsImhlaWdodCIsImhvdmVyIiwicm90IiwidE1hcCIsImhhc1RleHR1cmUiLCJtZXNoIiwicmVzaXplIiwiZHByIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2V0U2l6ZSIsInN0eWxlIiwic2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInRhcmdldEhvdmVyIiwibGFzdFRpbWUiLCJjdXJyZW50Um90IiwiYXV0b1JvdGF0aW9uU3BlZWQiLCJob3ZlclJvdGF0aW9uU3BlZWQiLCJoYW5kbGVNb3VzZU1vdmUiLCJlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJjbGllbnRYIiwibGVmdCIsInkiLCJjbGllbnRZIiwidG9wIiwic2l6ZSIsIk1hdGgiLCJtaW4iLCJjZW50ZXJYIiwiY2VudGVyWSIsInV2WCIsInV2WSIsInNxcnQiLCJoYW5kbGVNb3VzZUxlYXZlIiwicmFmSWQiLCJ1cGRhdGUiLCJ0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZHQiLCJlZmZlY3RpdmVIb3ZlciIsInJlbmRlciIsInNjZW5lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZ2V0RXh0ZW5zaW9uIiwibG9zZUNvbnRleHQiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Orb.tsx\n"));

/***/ })

});